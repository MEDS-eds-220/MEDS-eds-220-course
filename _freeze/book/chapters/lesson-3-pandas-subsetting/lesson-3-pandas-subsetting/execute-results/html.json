{
  "hash": "18b6353f271804ef4c815d1261bd7f45",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntoc-title: In this lesson\n---\n\n\n\n\n# 2 Subsetting\n\nIn this lesson we will learn different methods to select data from a `pandas.DataFrame`. Like it's often the case when working with the `pandas` package, there are *many* ways in which we can subset a data frame. Here we will review the core methods to do this. \n\nA summary of the methods covered in this lesson can be found in @fig-summary.\n\n## Learning objectives\nBy the end of this lesson, students will be able to:\n\n- Choose appropriate methods for selecting rows and columns from a `pandas.DataFrame`\n- Construct conditions to subset rows\n- Describe the difference between label-based subsetting and position-based subsetting\n- Apply best practies when using `iloc` and `loc` selection\n\n\n## About the data\n\nIn this lesson we will use annual estimates of bird species abundance in four coastal wetlands along the California coast. This dataset was derived for education purposes from the [UCSB SONGS Mitigation Monitoring: Wetland Performance Standard - Bird Abundance and Species Richness dataset](https://portal.edirepository.org/nis/mapbrowse?packageid=edi.649.6) @schroeter_ucsb_2024. \nThe SONGS dataset was collected as part of the [San Onofre Nuclear Generating Station (SONGS) San Dieguito Wetland Restoration monitoring program](https://marinemitigation.msi.ucsb.edu). \n\n![San Onofre Nuclear Generating Station in San Diego County, California. Source: Southern California Edison](/book/images/lesson-3/SONGS_aerial.jpg)\n\nThe annual bird species abundance estimates is a CSV file with 17 columns. You can see the first three rows below.\n\n::: {#e985ca79 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n      <th>SDW_winter</th>\n      <th>SDW_spring</th>\n      <th>SDW_fall</th>\n      <th>TJE_winter</th>\n      <th>TJE_spring</th>\n      <th>TJE_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2010</td>\n      <td>39.0</td>\n      <td>40.0</td>\n      <td>50.0</td>\n      <td>45.0</td>\n      <td>NaN</td>\n      <td>61.0</td>\n      <td>NaN</td>\n      <td>75.0</td>\n      <td>85.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>81.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2011</td>\n      <td>48.0</td>\n      <td>44.0</td>\n      <td>NaN</td>\n      <td>58.0</td>\n      <td>52.0</td>\n      <td>NaN</td>\n      <td>78.0</td>\n      <td>74.0</td>\n      <td>NaN</td>\n      <td>67.0</td>\n      <td>70.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2012</td>\n      <td>51.0</td>\n      <td>43.0</td>\n      <td>49.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>53.0</td>\n      <td>71.0</td>\n      <td>72.0</td>\n      <td>73.0</td>\n      <td>70.0</td>\n      <td>63.0</td>\n      <td>69.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe four wetlands where the bird surveys occured are Carpinteria Salt Marsh (CSM),  Mugu Lagoon (MUL), the San Dieguito Wetland (SDW), and the Tijuana Estuary (TJE). The values from the second column to the last column correspond to the number of different bird species recorded across the survey sites in each wetland during winter, spring, and fall of a given year. For example, the `CSM_fall` column has the number of species recorded in fall at Carpinteria Salt Marsh across years. The `year` column corresponds to the calendar year on which the data was collected. Surveys have happened yearly from 2010 to 2023. \n\n![Mugu Lagoon in Ventura County, California, seen from the Mugu Peak Trail. Source: USA National Park Service](/book/images/lesson-3/Mugu_Lagoon_from_the_Mugu_Peak_Trail.jpg)\n\n## CSV files\n\nA **CSV (Comma-Separated Values) file** is an open, simple text format for storing tabular data, with rows separated by line breaks and columns by commas. It's widely used in environmental science for sharing datasets like species counts and environmental monitoring data because itâ€™s easy to create, read, and process in different platforms, without the need of proprietary software.\n\nTo read in a CSV file into our Python workspace as `pandas.DataFrame` we use the `pandas.read_csv` function:\n\n::: {#e7023220 .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Read in file, argument is the file path\ndf = pd.read_csv('data/wetlands_seasonal_bird_diversity.csv')\n```\n:::\n\n\nNext, we obtain some high-level information about this data frame: \n\n::: {#d0bcd7ba .cell execution_count=3}\n``` {.python .cell-code}\n# Print data frame's first five rows \ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n      <th>SDW_winter</th>\n      <th>SDW_spring</th>\n      <th>SDW_fall</th>\n      <th>TJE_winter</th>\n      <th>TJE_spring</th>\n      <th>TJE_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2010</td>\n      <td>39.0</td>\n      <td>40.0</td>\n      <td>50.0</td>\n      <td>45.0</td>\n      <td>NaN</td>\n      <td>61.0</td>\n      <td>NaN</td>\n      <td>75.0</td>\n      <td>85.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>81.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2011</td>\n      <td>48.0</td>\n      <td>44.0</td>\n      <td>NaN</td>\n      <td>58.0</td>\n      <td>52.0</td>\n      <td>NaN</td>\n      <td>78.0</td>\n      <td>74.0</td>\n      <td>NaN</td>\n      <td>67.0</td>\n      <td>70.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2012</td>\n      <td>51.0</td>\n      <td>43.0</td>\n      <td>49.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>53.0</td>\n      <td>71.0</td>\n      <td>72.0</td>\n      <td>73.0</td>\n      <td>70.0</td>\n      <td>63.0</td>\n      <td>69.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2013</td>\n      <td>42.0</td>\n      <td>46.0</td>\n      <td>38.0</td>\n      <td>60.0</td>\n      <td>58.0</td>\n      <td>62.0</td>\n      <td>69.0</td>\n      <td>70.0</td>\n      <td>70.0</td>\n      <td>69.0</td>\n      <td>74.0</td>\n      <td>64.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2014</td>\n      <td>38.0</td>\n      <td>43.0</td>\n      <td>45.0</td>\n      <td>49.0</td>\n      <td>52.0</td>\n      <td>57.0</td>\n      <td>61.0</td>\n      <td>78.0</td>\n      <td>71.0</td>\n      <td>60.0</td>\n      <td>81.0</td>\n      <td>62.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#197533e9 .cell execution_count=4}\n``` {.python .cell-code}\n# Print data frame's last five rows \ndf.tail()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n      <th>SDW_winter</th>\n      <th>SDW_spring</th>\n      <th>SDW_fall</th>\n      <th>TJE_winter</th>\n      <th>TJE_spring</th>\n      <th>TJE_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>9</th>\n      <td>2019</td>\n      <td>39.0</td>\n      <td>39.0</td>\n      <td>40.0</td>\n      <td>57.0</td>\n      <td>52.0</td>\n      <td>53.0</td>\n      <td>54.0</td>\n      <td>55.0</td>\n      <td>53.0</td>\n      <td>63.0</td>\n      <td>54.0</td>\n      <td>50.0</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>2020</td>\n      <td>46.0</td>\n      <td>NaN</td>\n      <td>47.0</td>\n      <td>56.0</td>\n      <td>NaN</td>\n      <td>66.0</td>\n      <td>57.0</td>\n      <td>NaN</td>\n      <td>58.0</td>\n      <td>54.0</td>\n      <td>40.0</td>\n      <td>54.0</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>2021</td>\n      <td>47.0</td>\n      <td>44.0</td>\n      <td>53.0</td>\n      <td>54.0</td>\n      <td>55.0</td>\n      <td>60.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>57.0</td>\n      <td>53.0</td>\n      <td>68.0</td>\n      <td>51.0</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>2022</td>\n      <td>40.0</td>\n      <td>46.0</td>\n      <td>49.0</td>\n      <td>60.0</td>\n      <td>55.0</td>\n      <td>65.0</td>\n      <td>57.0</td>\n      <td>60.0</td>\n      <td>57.0</td>\n      <td>60.0</td>\n      <td>61.0</td>\n      <td>60.0</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>2023</td>\n      <td>56.0</td>\n      <td>43.0</td>\n      <td>36.0</td>\n      <td>72.0</td>\n      <td>59.0</td>\n      <td>53.0</td>\n      <td>64.0</td>\n      <td>63.0</td>\n      <td>33.0</td>\n      <td>60.0</td>\n      <td>56.0</td>\n      <td>38.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#00e73311 .cell execution_count=5}\n``` {.python .cell-code}\n# Print data frame's column names\ndf.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nIndex(['year', 'CSM_winter', 'CSM_spring', 'CSM_fall', 'MUL_winter',\n       'MUL_spring', 'MUL_fall', 'SDW_winter', 'SDW_spring', 'SDW_fall',\n       'TJE_winter', 'TJE_spring', 'TJE_fall'],\n      dtype='object')\n```\n:::\n:::\n\n\n::: {#8175bdbb .cell execution_count=6}\n``` {.python .cell-code}\n# List the data types of each column\ndf.dtypes\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nyear            int64\nCSM_winter    float64\nCSM_spring    float64\nCSM_fall      float64\nMUL_winter    float64\nMUL_spring    float64\nMUL_fall      float64\nSDW_winter    float64\nSDW_spring    float64\nSDW_fall      float64\nTJE_winter    float64\nTJE_spring    float64\nTJE_fall      float64\ndtype: object\n```\n:::\n:::\n\n\n::: {#5c14cde6 .cell execution_count=7}\n``` {.python .cell-code}\n# Print data frame's shape: output is a tuple (# rows, # columns)\ndf.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n(14, 13)\n```\n:::\n:::\n\n\n## Selecting a single column\n\nSelecting a single column by column name is the simplest case for selecting data in a data frame. The genereal syntax to do this is:\n```python\ndf['column_name']\n```\nNotice the column name is given as string inside the square brackets. \nThis is an example of **label-based subsetting**, which means we want to select data from our data frame using the *names* of the columns, *not their position*. When we select rows or column using their position, we are doing **position-based subsetting**. We'll see some methods to do this when we move into selecting rows.\n\n#### Example \n Suppose we are interested in the number of bird species observed at the Mugu Lagoon in spring. We can access that single column in this way:\n\n::: {#30bc2716 .cell execution_count=8}\n``` {.python .cell-code}\n# Select a single column by using square brackets []\nmul_spring = df['MUL_spring']\n\n# Print first five elements in this column\nmul_spring.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n0     NaN\n1    52.0\n2    58.0\n3    58.0\n4    52.0\nName: MUL_spring, dtype: float64\n```\n:::\n:::\n\n\nSince we only selected a single column, `mul_spring` is a `pandas.Series`:\n\n::: {#3c2a0d2f .cell execution_count=9}\n``` {.python .cell-code}\n# Check the type of the ouput\nprint(type(mul_spring))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.series.Series'>\n```\n:::\n:::\n\n\n:::{.callout-note}\n## `pd.DataFrame` = dictionary of columns\nRemember we can think of a `pandas.DataFrame` as a dictionary of its columns? Then we can access a single column using the column name as the key, just like we would do in a dictionary. That is the  we just used: `df['column_name']`.\n:::\n\nWe can also do label-based subsetting of a single column  using attribute syntax:\n```python\ndf.column_name\n```\n\nFor example, to see the head of the `MUL_spring` column we would do:\n\n::: {#0aaea805 .cell execution_count=10}\n``` {.python .cell-code}\ndf.MUL_spring.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n0     NaN\n1    52.0\n2    58.0\n3    58.0\n4    52.0\nName: MUL_spring, dtype: float64\n```\n:::\n:::\n\n\n:::{.callout-caution}\n## Favor `df['column_name']` instead of `df.column_name`\nIn general, it is better to use the `df['column_name']` syntax. A couple reasons why are:\n\n- `df['column_name']` can take in any column name, while `df.column_name` only works if the column name has no spaces or special characters\n- `df['column_name']` avoids conflicts with `pd.DataFrame` methods and attributes. For example, if `df` has a column named `count`, it's ambiguous whehter `pd.count` is referring to the [`count()` method](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.count.html) or the `count` column.\n:::\n\n## Selecting multiple columns...\n\n### ... using a list of column names\n\nWe can select multiple columns in a single call by passing a list with the column names to the square brackets `[]`:\n\n```python\ndf[['column_1', 'column_10', 'column_245']]\n```\n\nNotice there are double square brackets. This is because we are passing the list of names `['column_1', 'column_10', 'column_245']` to the selection brakcets `[]`. \n\n\n:::{.callout-tip}\n## Check-in\nIs this an example of label-based selection or location-based selection?\n:::\n\n#### Example\nIf we want to look at the species in the Tijuana Estuary during winter and fall, then we can select these columns like this:\n\n::: {#cea37ce6 .cell execution_count=11}\n``` {.python .cell-code}\n# select columns with names \"europe\" and \"asia\"\ntje_wf = df[['TJE_winter','TJE_fall']]\n```\n:::\n\n\nNotice there are double square brackets. This is because we are passing the list of names `['europe','asia']` to the selection brakcets `[]`. \n\n:::{.callout-tip}\n## Check-in\nWhat is the type and shape of the `tje_wf` output? Verify your answer.\n\n\n\n:::\n\n### ... using a slice\n\nTo select a slice of the columns we will use a special case of **`loc` selection** (we'll cover the general one by the end of the lesson). The syntax will be\n\n```python\ndf.loc[ : , 'column_start':'column_end']\n```\nwhere `column_start` and `column_end` are, respectively, the starting point and endpoint of the column slice we want to subset from the data frame. \n\nNotice two things:\n\n- the first value passed to `loc` is used for selecting rows, using a colon `:` as the row-selection parameter means \"select all the rows\"\n- the slice of the data frame we'll obtain includes both endpoints of the slice `'column_start':'column_end'`. In other words, we'll get the `column_start` column *and* the `column_end` column. This is different from how slicing works in base Python and NumPy, where the endpoint is not included.\n\n#### Example\n\nLet's select the slice of columns that covers all data from Carpinteria Salt Marsh and Mugu Lagoon. This corresponds to all columns between `CSM_winter` and `MUL_fall`.\n\n::: {#8d835d26 .cell execution_count=13}\n``` {.python .cell-code}\n# Select columns between 'CSM_winter' and 'MUL_fall'\ncsm_mul = df.loc[:,'CSM_winter':'MUL_fall']\ncsm_mul.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>39.0</td>\n      <td>40.0</td>\n      <td>50.0</td>\n      <td>45.0</td>\n      <td>NaN</td>\n      <td>61.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>48.0</td>\n      <td>44.0</td>\n      <td>NaN</td>\n      <td>58.0</td>\n      <td>52.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>51.0</td>\n      <td>43.0</td>\n      <td>49.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>53.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>42.0</td>\n      <td>46.0</td>\n      <td>38.0</td>\n      <td>60.0</td>\n      <td>58.0</td>\n      <td>62.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>38.0</td>\n      <td>43.0</td>\n      <td>45.0</td>\n      <td>49.0</td>\n      <td>52.0</td>\n      <td>57.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### ... using a condition\n\n<!-- TO DO -->\n\nfall_columns = df.filter(like='fall')\n\n\n## Selecting rows...\nNow that we are familiar with some methods for selecting columns, let's move on to selecting rows. \n\n### ... using a condition\nSelecting rows that satisfy a particular condition is one of the most usual kinds of row subsetting. The general syntax for this type of selection is \n```python\ndf[condition_on_rows]\n```\nThat `condition_of_rows` can be a myriad things, let's see some usual scenarios.\n\n#### Example\n\nSuppose we are intersted in all data after 2020. We can select these rows in this way:\n\n::: {#e893ae19 .cell execution_count=14}\n``` {.python .cell-code}\n# Select all rows with year > 2020\npost_2020 = df[df['year']>2020]\npost_2020\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n      <th>SDW_winter</th>\n      <th>SDW_spring</th>\n      <th>SDW_fall</th>\n      <th>TJE_winter</th>\n      <th>TJE_spring</th>\n      <th>TJE_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>11</th>\n      <td>2021</td>\n      <td>47.0</td>\n      <td>44.0</td>\n      <td>53.0</td>\n      <td>54.0</td>\n      <td>55.0</td>\n      <td>60.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>57.0</td>\n      <td>53.0</td>\n      <td>68.0</td>\n      <td>51.0</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>2022</td>\n      <td>40.0</td>\n      <td>46.0</td>\n      <td>49.0</td>\n      <td>60.0</td>\n      <td>55.0</td>\n      <td>65.0</td>\n      <td>57.0</td>\n      <td>60.0</td>\n      <td>57.0</td>\n      <td>60.0</td>\n      <td>61.0</td>\n      <td>60.0</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>2023</td>\n      <td>56.0</td>\n      <td>43.0</td>\n      <td>36.0</td>\n      <td>72.0</td>\n      <td>59.0</td>\n      <td>53.0</td>\n      <td>64.0</td>\n      <td>63.0</td>\n      <td>33.0</td>\n      <td>60.0</td>\n      <td>56.0</td>\n      <td>38.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLet's break down what is happening here. The condition for our rows is `df['year']>2020`, this is a `pandas.Series` with boolean values (`True` or `False`) indicating which rows satisfy the condition year>2020:\n\n::: {#8a0c3285 .cell execution_count=15}\n``` {.python .cell-code}\n# Check the type of df['year']>1996\nprint(type(df['year']>2020))\n\n# Print the boolean series\ndf['year']>2020\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.series.Series'>\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n0     False\n1     False\n2     False\n3     False\n4     False\n5     False\n6     False\n7     False\n8     False\n9     False\n10    False\n11     True\n12     True\n13     True\nName: year, dtype: bool\n```\n:::\n:::\n\n\n When we pass such a series of boolean values to the selection brackets `[]` we keep only the rows that correspond to a `True` value. \n\n<!-- TO DO: would be nice to add a diagram about selecting rows -->\n\n:::{.callout-tip}\n## Check-in\n Get the subset of our data frame on which the San Dieguito Wetland has at least 75 species recorded during spring.\n:::\n\n#### Example\n\nSuppose we want to look at data from years 2012 to 2015 (including both years). One way of doing this is to use the `between` operator in our condition:\n\n::: {#59dc777c .cell execution_count=16}\n``` {.python .cell-code}\nsubset = df[df['year'].between(2012, 2015)]\nsubset\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n      <th>SDW_winter</th>\n      <th>SDW_spring</th>\n      <th>SDW_fall</th>\n      <th>TJE_winter</th>\n      <th>TJE_spring</th>\n      <th>TJE_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2</th>\n      <td>2012</td>\n      <td>51.0</td>\n      <td>43.0</td>\n      <td>49.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>53.0</td>\n      <td>71.0</td>\n      <td>72.0</td>\n      <td>73.0</td>\n      <td>70.0</td>\n      <td>63.0</td>\n      <td>69.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2013</td>\n      <td>42.0</td>\n      <td>46.0</td>\n      <td>38.0</td>\n      <td>60.0</td>\n      <td>58.0</td>\n      <td>62.0</td>\n      <td>69.0</td>\n      <td>70.0</td>\n      <td>70.0</td>\n      <td>69.0</td>\n      <td>74.0</td>\n      <td>64.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2014</td>\n      <td>38.0</td>\n      <td>43.0</td>\n      <td>45.0</td>\n      <td>49.0</td>\n      <td>52.0</td>\n      <td>57.0</td>\n      <td>61.0</td>\n      <td>78.0</td>\n      <td>71.0</td>\n      <td>60.0</td>\n      <td>81.0</td>\n      <td>62.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2015</td>\n      <td>44.0</td>\n      <td>42.0</td>\n      <td>45.0</td>\n      <td>58.0</td>\n      <td>50.0</td>\n      <td>51.0</td>\n      <td>71.0</td>\n      <td>61.0</td>\n      <td>65.0</td>\n      <td>73.0</td>\n      <td>76.0</td>\n      <td>64.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLet's break down this code: \n\n1. `df['year']` is the column with the year values, a `pandas.Series`\n\n2. in `df['year'].between()`, we have that [`between` is a method for the `pandas.Series`](https://pandas.pydata.org/docs/reference/api/pandas.Series.between.html) and we are calling it using the dot `.`\n\n3. `(2012, 2015)` are the parameters for the `between()` method, from the `pandas` documentation we can see this method will subset including both endpoints\n\n4. `df['year'].between(2012, 2015)` is then a `pandas.Series` of boolean values indicating which rows have year equal to 2012, 2013, 2014, or 2015. \n\n5. when we put `df['year'].between(2012, 2015)` inside the selection brackets `[]` we obtain the rows of the data frame with year equal to 2012, ..., 2015.\n\n:::{.callout-warning}\n## Avoid using `loc` for selecting only rows\nIt is equivalent to write\n\n```python\n# Select rows with year<2015\ndf[df['year'] < 2015]\n```\nand\n```python\n# Select rows with year<2015 using loc\ndf.loc[ df['year'] <2015 , :]\n```\nIn the second one:\n\n- we are using the `df.loc[ row-selection , column-selection]` syntax\n\n- the `row-selection` parameter is the condition `df['year']<2015`\n\n- the `column-selection` parameter is a colon `:`, which indicates we want all columns for the rows we are selecting.\n\nWe prefer the first syntax when we are selecting rows and not columns since it is simpler.\n:::\n\n### ... using multiple conditions\nWe can combine multipe conditions to select rows by surrounding each one in parenthesis `()` and using the or operator `|` and the and operator `&`.\n\n#### Example: or \n\nLet's select rows in which the Carpinteria Salt Marsh has more than 50 registered in winter *or* fall:\n\n::: {#f1f7abaf .cell execution_count=17}\n``` {.python .cell-code}\ndf[ (df['CSM_winter']>50) | (df['CSM_fall']>50)]\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n      <th>SDW_winter</th>\n      <th>SDW_spring</th>\n      <th>SDW_fall</th>\n      <th>TJE_winter</th>\n      <th>TJE_spring</th>\n      <th>TJE_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2</th>\n      <td>2012</td>\n      <td>51.0</td>\n      <td>43.0</td>\n      <td>49.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>53.0</td>\n      <td>71.0</td>\n      <td>72.0</td>\n      <td>73.0</td>\n      <td>70.0</td>\n      <td>63.0</td>\n      <td>69.0</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>2021</td>\n      <td>47.0</td>\n      <td>44.0</td>\n      <td>53.0</td>\n      <td>54.0</td>\n      <td>55.0</td>\n      <td>60.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>57.0</td>\n      <td>53.0</td>\n      <td>68.0</td>\n      <td>51.0</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>2023</td>\n      <td>56.0</td>\n      <td>43.0</td>\n      <td>36.0</td>\n      <td>72.0</td>\n      <td>59.0</td>\n      <td>53.0</td>\n      <td>64.0</td>\n      <td>63.0</td>\n      <td>33.0</td>\n      <td>60.0</td>\n      <td>56.0</td>\n      <td>38.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n#### Example: and\n\nLet's select rows with in which both the Carpinteria Salt Marsh and the San Dieguito Wetland have more than 60 reported bird species during spring:\n\n::: {#689dff0a .cell execution_count=18}\n``` {.python .cell-code}\ndf[ (df['CSM_spring']>60) & (df['SDW_spring']>60)]\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n      <th>SDW_winter</th>\n      <th>SDW_spring</th>\n      <th>SDW_fall</th>\n      <th>TJE_winter</th>\n      <th>TJE_spring</th>\n      <th>TJE_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAn empty data frame! That's ok, it just means there are no rows that satisfy the given condition.\n\n### ... by position\n\nAll the selections we have done so far have been using labels. Sometimes we may want to select certain rows depending on their *actual position* in the data frame in other words, using **position-based subsetting**.  To do this, we use **`iloc` selection** with the syntax\n```python\n df.iloc[row-indices]\n ```\n `iloc` stands for integer-location based indexing.\n\n#### Example\n\n::: {#80f5bad9 .cell execution_count=19}\n``` {.python .cell-code}\n# Select the fifth row (index=4)\ndf.iloc[4]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nyear          2014.0\nCSM_winter      38.0\nCSM_spring      43.0\nCSM_fall        45.0\nMUL_winter      49.0\nMUL_spring      52.0\nMUL_fall        57.0\nSDW_winter      61.0\nSDW_spring      78.0\nSDW_fall        71.0\nTJE_winter      60.0\nTJE_spring      81.0\nTJE_fall        62.0\nName: 4, dtype: float64\n```\n:::\n:::\n\n\n::: {#6348fb1b .cell execution_count=20}\n``` {.python .cell-code}\n# Select rows 9 through 13, inclduing 13\ndf.iloc[9:14]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>CSM_winter</th>\n      <th>CSM_spring</th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n      <th>MUL_spring</th>\n      <th>MUL_fall</th>\n      <th>SDW_winter</th>\n      <th>SDW_spring</th>\n      <th>SDW_fall</th>\n      <th>TJE_winter</th>\n      <th>TJE_spring</th>\n      <th>TJE_fall</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>9</th>\n      <td>2019</td>\n      <td>39.0</td>\n      <td>39.0</td>\n      <td>40.0</td>\n      <td>57.0</td>\n      <td>52.0</td>\n      <td>53.0</td>\n      <td>54.0</td>\n      <td>55.0</td>\n      <td>53.0</td>\n      <td>63.0</td>\n      <td>54.0</td>\n      <td>50.0</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>2020</td>\n      <td>46.0</td>\n      <td>NaN</td>\n      <td>47.0</td>\n      <td>56.0</td>\n      <td>NaN</td>\n      <td>66.0</td>\n      <td>57.0</td>\n      <td>NaN</td>\n      <td>58.0</td>\n      <td>54.0</td>\n      <td>40.0</td>\n      <td>54.0</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>2021</td>\n      <td>47.0</td>\n      <td>44.0</td>\n      <td>53.0</td>\n      <td>54.0</td>\n      <td>55.0</td>\n      <td>60.0</td>\n      <td>57.0</td>\n      <td>58.0</td>\n      <td>57.0</td>\n      <td>53.0</td>\n      <td>68.0</td>\n      <td>51.0</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>2022</td>\n      <td>40.0</td>\n      <td>46.0</td>\n      <td>49.0</td>\n      <td>60.0</td>\n      <td>55.0</td>\n      <td>65.0</td>\n      <td>57.0</td>\n      <td>60.0</td>\n      <td>57.0</td>\n      <td>60.0</td>\n      <td>61.0</td>\n      <td>60.0</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>2023</td>\n      <td>56.0</td>\n      <td>43.0</td>\n      <td>36.0</td>\n      <td>72.0</td>\n      <td>59.0</td>\n      <td>53.0</td>\n      <td>64.0</td>\n      <td>63.0</td>\n      <td>33.0</td>\n      <td>60.0</td>\n      <td>56.0</td>\n      <td>38.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNotice that, since we are back to indexing by position, the right endpoint of the slice is not included in the ouput. \n\n## Selecting rows and columns simultaneously...\n\nSelecting rows and columns simultaneously can be done using `loc` (labels) or `iloc` (positions).\n\n### ...by labels or conditions\nWhen we want to select rows and columns simultaneously by labels (including using conditions) we can use `loc` selection with the syntax \n\n```python\ndf.loc[ row-selection , column-selection]\n```\n\nspecifying both paratmers: `row-selection` and `column-selection`. These parameters can be a condition or a subset of labels from the index or the column names. \n\n#### Example\n\nLet's select the winter surveys for Mugu Lagoon and the Tijuana Estuary after 2020:\n\n::: {#64503546 .cell execution_count=21}\n``` {.python .cell-code}\ndf.loc[df['year']>2020, ['MUL_winter','TJE_winter']]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>MUL_winter</th>\n      <th>TJE_winter</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>11</th>\n      <td>54.0</td>\n      <td>53.0</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>60.0</td>\n      <td>60.0</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>72.0</td>\n      <td>60.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLet's break down this code:\n\n- we are using the `df.loc[ row-selection , column-selection]` syntax\n\n- the `row-selection` parameter is the condition `df['year']>2020`, which is a boolean array saying which years are greater than 2020\n\n- the `column-selection` parameter is `['MUL_winter','TJE_winter']` which is a list with the names of the two columns we are interested in. \n\n\n### ... by position\n\nWhen we want to select rows and columns simultaneously by position we use `iloc` selection with the syntax:\n```python\ndf.iloc[ row-indices , column-indices]\n```\n\n#### Example\n\nSuppose we want to select rows 3-7 (including 7) and columns 3 and 4:\n\n::: {#7a3910c1 .cell execution_count=22}\n``` {.python .cell-code}\ndf.iloc[ 3:8, [3,4] ]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>CSM_fall</th>\n      <th>MUL_winter</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>3</th>\n      <td>38.0</td>\n      <td>60.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>45.0</td>\n      <td>49.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>45.0</td>\n      <td>58.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>47.0</td>\n      <td>63.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>43.0</td>\n      <td>57.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLet's break it down:\n\n- we are using the `df.iloc[ row-indices , column-indices]` syntax to select by position\n\n- the `row-indices` parameter is the slice *of integer indices* 3:8. Remember the right endpoint (8) won't be included.\n\n- the `column-indices` parameter is the list of integer indices 3 and 4. This means we are selecting the fourth and fifth column.\n\n## Notes about `loc` and `iloc`\n\n::: {.callout-caution}\n## `iloc` vs. `loc`: which one does what?\nAt the beginning, the difference between `iloc` and `loc` can be confusing. Remember the `i` in `iloc` stands for *integer location*, this reminds us `iloc` only uses integer indexing to retrieve information from the data frames in the same way as indexing for Python lists.\n\nIf you want to dive deeper, this is a great discussion about the difference between `iloc` and `loc`: [Stackoverflow - How are iloc and loc different?](https://stackoverflow.com/questions/31593201/how-are-iloc-and-loc-different/31593712#31593712)\n\nAnd, as always, the documentation will provide you with more information:\n[`pandas.DataFrame.loc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html) and [`pandas.DataFrame.iloc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html).\n:::\n\n\n:::{.callout-warning}\n## `iloc` for column selection? Avoid it!\nWe can also access columns by position using `iloc` - but it is best not to if possible.\n\nSuppose we want to access the 10th column in the data frame - then we want to select a column *by position*. In this case the 10th column is the annual sea level rise data and the 10th position corresponds to the index 9. We can select this column by position using the `iloc` selection:\n\n::: {#753ade2a .cell execution_count=23}\n``` {.python .cell-code}\n# select column by position using iloc\n# the syntax is iloc[row-indices, column-indices]\n# [:,9] means \"select all rows from the 10th column\"\nannual_rise_3 = df.iloc[:,9]\nannual_rise_3.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n0    85.0\n1     NaN\n2    73.0\n3    70.0\n4    71.0\nName: SDW_fall, dtype: float64\n```\n:::\n:::\n\n\nUnless you are *really* looking for information about *the 10th column*, **do not access a column by position**. This is bound to break in many ways:\n\n- it relies on a person correctly counting the position of a column. Even with a small dataset this can be prone to error.\n\n- it is not explicit: if we want information about sea level rise `df.annual_sea_level_rise` or `df['annual_sea_level_rise']` are explicitely telling us we are accessing that information. `df.iloc[:,9]` is obscure and uninformative.\n\n- datastets can get updated. Maybe a new column was added before `annual_sea_level_rise`, this would change the position of the column, which would make any code depending on `df.iloc[:,9]` invalid. \n\n**Accessing columns by labels helps reproducibility!**\n:::\n\n## Summary\n:::{.column-page}\n![Flow diagram for selecting core methods to subset a `pandas.DataFrame`.](/book/images/lesson-3/pandas-selection-diagram.png){#fig-summary}\n:::\n\n## Resources\n\nWhat is presented in this section is a comprehensive, but not  exhaustive list of methods to select data in `pandas.DataFrames`. There are *so many* ways to subset data to get the same result. Some of the content from this lesson is adapted from the following resources and I encourage you to read them to learn more! \n\nðŸ“– [Pandas getting started tutorials - How to I select a subset of a\nDataFrame](https://pandas.pydata.org/docs/getting_started/intro_tutorials/03_subset_data.html) \n\nðŸ“– [Pandas documentation - User Guide - Indexing and Selecting Data](https://pandas.pydata.org/docs/user_guide/indexing.html#indexing-slicing-with-labels)\n\nðŸ“– [Python for Data Analysis, 3E - Getting started with pandas](https://wesmckinney.com/book/pandas-basics)\n\n",
    "supporting": [
      "lesson-3-pandas-subsetting_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}