{
  "hash": "25d73f4452df2ed44190a6b5eeb0a65c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 10 Streamline your code\n---\n\n\n\nIn this lesson we will learn how to extract geospatial data from a CSV to create a `geopandas.GeoDataFrame`, introduce more customizations for maps and matplotlib figures, and go over strategies to streamline our code.\n\n<!--\nTODO: learning objectives\n-->\n\n## About the data\n\nThe U.S. energy landscape relies on a mix of fossil fuels and renewables, each with unique environmental and economic impacts. As the nation works toward sustainability and energy security, understanding this energy mix is essential for informed policy and progress toward cleaner energy.\n\nIn this lesson, we will use data from the U.S. [Energy Information Administration (EIA)](https://www.eia.gov) about [operable electric generating plants in the United States by energy source, as of May 2023](https://atlas.eia.gov/datasets/eia::power-plants/about). The dataset includes information on plant types and energy sources, offering insights into the diversity of power sources—from fossil fuels to renewables—that supply electricity nationwide. The dataset's metadata can be [accessed here](https://eia.maps.arcgis.com/sharing/rest/content/items/bf5c5110b1b944d299bb683cdbd02d2a/info/metadata/metadata.xml?format=default&output=html)\n<!-- TODO: add citation -->\n<!-- TODO: add image -->\nThe EIA data on electric plants has been downloaded as a CSV and reprojected into the EPSG:4269 CRS for this lesson. It can be accessed [here](https://github.com/carmengg/eds-220-book/blob/main/data/power_plants_epsg4269.csv).\n\n<!-- TODO: column descriptions: lat lon, -->\n\nAdditionally, we will use a [TIGER shapefile of the US states from the United States Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.2022.html#list-tab-790442341). \n[TIGER](https://en.wikipedia.org/wiki/Topologically_Integrated_Geographic_Encoding_and_Referencing) stands for Topologically Integrated Geographic Encoding and Referencing. This used to be the data format the US Census distributed geospatial data, but since 2008 TIGER files are converted to shapefiles. You can view the metadata for all the TIGER shapefiles [here](https://www.census.gov/programs-surveys/geography/technical-documentation/complete-technical-documentation/tiger-geo-line.html). \n\nFollow these steps to download shapefile with the United States' states:\n\n1. At the bottom of the [2022 page](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.2022.html#list-tab-790442341), under Download, click on \"Web Interface\"\n2. For year, select 2022, and for layer type select \"States (and equivalent)\". Click submit. \n3. Click on \"Download national file\".\n\n\nThe column descriptions for the US states shapefile are:\n\n![Source: TIGER/Line Shapefiles Technical Documentation](/book/images/lesson-11/tiger_shp_columns.png)\n\n\n## CSV to `geopandas.GeoDataFrame`\n\nLet's start by importing packages and updating viewing options:\n\n\n::: {#722a9657 .cell execution_count=1}\n``` {.python .cell-code}\nimport os\n\nimport pandas as pd\nfrom pandas.api.types import is_string_dtype, is_numeric_dtype\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\n\n# Display all columns when looking at dataframes\npd.set_option(\"display.max.columns\", None)\n```\n:::\n\n\nNext, we import the power plants dataset.  In this lesson, we have downloaded the data into a `data/` folder in the same level as our notebook.\n\n::: {#3052db7b .cell execution_count=2}\n``` {.python .cell-code}\n# Import power plants data\nURL = 'https://raw.githubusercontent.com/carmengg/eds-220-book/refs/heads/main/data/power_plants_epsg4269.csv'\npower_plants = pd.read_csv(URL)\n\n# Simpify column names\npower_plants.columns = power_plants.columns.str.lower()\n\n# Drop first column\npower_plants = power_plants.drop(columns='unnamed: 0')\n\npower_plants.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>objectid</th>\n      <th>plant_code</th>\n      <th>plant_name</th>\n      <th>utility_id</th>\n      <th>utility_name</th>\n      <th>sector_name</th>\n      <th>street_address</th>\n      <th>city</th>\n      <th>county</th>\n      <th>state</th>\n      <th>zip</th>\n      <th>primsource</th>\n      <th>source_desc</th>\n      <th>tech_desc</th>\n      <th>install_mw</th>\n      <th>total_mw</th>\n      <th>bat_mw</th>\n      <th>bio_mw</th>\n      <th>coal_mw</th>\n      <th>geo_mw</th>\n      <th>hydro_mw</th>\n      <th>hydrops_mw</th>\n      <th>ng_mw</th>\n      <th>nuclear_mw</th>\n      <th>crude_mw</th>\n      <th>solar_mw</th>\n      <th>wind_mw</th>\n      <th>other_mw</th>\n      <th>source</th>\n      <th>period</th>\n      <th>longitude</th>\n      <th>latitude</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>11570</td>\n      <td>1</td>\n      <td>Sand Point</td>\n      <td>63560</td>\n      <td>TDX Sand Point Generating, LLC</td>\n      <td>Electric Utility</td>\n      <td>100 Power Plant Way</td>\n      <td>Sand Point</td>\n      <td>Aleutians East</td>\n      <td>Alaska</td>\n      <td>99661.0</td>\n      <td>petroleum</td>\n      <td>Petroleum = 1.3 MW, Wind = 0.4 MW</td>\n      <td>Petroleum Liquids; Onshore Wind Turbine;</td>\n      <td>3.7</td>\n      <td>1.7</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>1.3</td>\n      <td>NaN</td>\n      <td>0.4</td>\n      <td>NaN</td>\n      <td>EIA-860, EIA-860M and EIA-923</td>\n      <td>202305.0</td>\n      <td>-160.497222</td>\n      <td>55.339722</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>11571</td>\n      <td>2</td>\n      <td>Bankhead Dam</td>\n      <td>195</td>\n      <td>Alabama Power Co</td>\n      <td>Electric Utility</td>\n      <td>19001 Lock 17 Road</td>\n      <td>Northport</td>\n      <td>Tuscaloosa</td>\n      <td>Alabama</td>\n      <td>35476.0</td>\n      <td>hydroelectric</td>\n      <td>Hydroelectric = 53 MW</td>\n      <td>Conventional Hydroelectric</td>\n      <td>53.9</td>\n      <td>53.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>53.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>EIA-860, EIA-860M and EIA-923</td>\n      <td>202305.0</td>\n      <td>-87.356823</td>\n      <td>33.458665</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>11572</td>\n      <td>3</td>\n      <td>Barry</td>\n      <td>195</td>\n      <td>Alabama Power Co</td>\n      <td>Electric Utility</td>\n      <td>North Highway 43</td>\n      <td>Bucks</td>\n      <td>Mobile</td>\n      <td>Alabama</td>\n      <td>36512.0</td>\n      <td>natural gas</td>\n      <td>Coal = 1118.5 MW, Natural Gas = 1296.2 MW</td>\n      <td>Conventional Steam Coal; Natural Gas Fired Com...</td>\n      <td>2569.5</td>\n      <td>2414.7</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>1118.5</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>1296.2</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>EIA-860, EIA-860M and EIA-923</td>\n      <td>202305.0</td>\n      <td>-88.010300</td>\n      <td>31.006900</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<!--TO DO: Need to drop the unnamed column from file--> \n\nThe power plants file is a CSV. Unlike shapefiles or other geospatial file formats, `geopandas` doesn't have a way to extract a geometry column from a CSV file, so we will need to create this geometry manually. \n\nTo do so we will use the longitude and latitude columns in the CSV, these indicate the location of the power plants in the NAD83 CRS (EPSG:4269).\nWe can use this information to create a new `geopandas.GeoDataFrame` from the `pandas.DataFrame` using the `geopandas` function [`points_from_xy()`](https://geopandas.org/en/stable/docs/reference/api/geopandas.points_from_xy.html):\n\n::: {#59144c11 .cell execution_count=3}\n``` {.python .cell-code}\n# Create points from latitude and longitude\npoints = gpd.points_from_xy(power_plants.longitude, \n                            power_plants.latitude)\n\n# Create geodataframe\npower_plants = gpd.GeoDataFrame(power_plants,    # Data\n                                geometry=points, # Specify geometry column\n                                crs='EPSG:4269'  # Specify CRS\n                                )\n```\n:::\n\n\nLet's check that we now have a `geometry` column:\n\n::: {#8bc74b26 .cell execution_count=4}\n``` {.python .cell-code}\npower_plants['geometry']\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0        POINT (-160.49722 55.33972)\n1         POINT (-87.35682 33.45867)\n2         POINT (-88.01030 31.00690)\n3         POINT (-86.28306 32.58389)\n4        POINT (-106.37500 31.75690)\n                    ...             \n12004     POINT (-82.37595 35.38014)\n12005     POINT (-79.36770 36.00932)\n12006     POINT (-79.73631 35.27343)\n12007     POINT (-73.91048 42.87657)\n12008     POINT (-77.27590 41.83800)\nName: geometry, Length: 12009, dtype: geometry\n```\n:::\n:::\n\n\nWith the `geometry` column and CRS, we can plot our dataset:\n\n::: {#0c2ab781 .cell execution_count=5}\n``` {.python .cell-code}\npower_plants.plot()  \n```\n\n::: {.cell-output .cell-output-display}\n![](lesson-11-csv-to-geo_files/figure-html/cell-6-output-1.png){width=580 height=408}\n:::\n:::\n\n\n## f-strings\n\nSo far, we have printed variables using string concatenation inside the `print()` function. \nThis means that we write commas between every string and variable we want to print, and then the `print()` function concatenates these into a single string. For example:\n\n::: {#01f1b30c .cell execution_count=6}\n``` {.python .cell-code}\nprint('CRS: ', power_plants.crs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCRS:  EPSG:4269\n```\n:::\n:::\n\n\nAnother popular way of mixing strings and variables in print statements is by creating an **f-string** which stands for \"formatted string\". \nThe simplest syntax for an f-string is:\n```python\nf\" some text {replace}\"\n```\nwhere `replace` can be a variable, an expression, or a function or method call. \nFor example:\n\n::: {#0c2521e0 .cell execution_count=7}\n``` {.python .cell-code}\n# Explore CRS\nprint(f\"ellipsoid: {power_plants.crs.ellipsoid}\")\nprint(f\"datum: {power_plants.crs.datum}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nellipsoid: GRS 1980\ndatum: North American Datum 1983\n```\n:::\n:::\n\n\nWe just created a string replacing the value inside the curly brackets `{}`. \n\nOne of the advantages of using f-strings is that they offer customization for formatting the output:\n\n::: {#a1b68883 .cell execution_count=8}\n``` {.python .cell-code}\n# Set the label width to 25 characters, aligning the answers\nprint(f\"{'Is the CRS geographic?:':<25} {power_plants.crs.is_geographic}\")\nprint(f\"{'Is the CRS projected?:':<25} {power_plants.crs.is_projected}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs the CRS geographic?:   True\nIs the CRS projected?:    False\n```\n:::\n:::\n\n\n:::{.callout-caution}\n## Use f-strings or not?\n\nWhether you use an f-string or simply concatenate strings with variables inside your print statements depends entirely on the application. For quickly checking a variable, a print statement might be enough, while using f-strings can be better to include custom messages during runtime. The best tool can be different depending on the task!\n\nThese are some good resources to learn more about f-string formatting:\n\n- [Real Python - Python's F-String for String Interpolation and Formatting](https://realpython.com/python-f-strings/)\n\n- [Python documentation- Format Specification Mini-Language](https://docs.python.org/3/library/string.html#formatspec)\n:::\n\n## Import shapefile\n\nLet's import the TIGER shapefile\n\n::: {#b85251a0 .cell execution_count=9}\n``` {.python .cell-code}\n# Import states data\nfp = os.path.join('data','tl_2022_us_state','tl_2022_us_state.shp')\nstates = gpd.read_file(fp)\n\n# Simplify column names \nstates.columns = states.columns.str.lower()\n\nstates.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>region</th>\n      <th>division</th>\n      <th>statefp</th>\n      <th>statens</th>\n      <th>geoid</th>\n      <th>stusps</th>\n      <th>name</th>\n      <th>lsad</th>\n      <th>mtfcc</th>\n      <th>funcstat</th>\n      <th>aland</th>\n      <th>awater</th>\n      <th>intptlat</th>\n      <th>intptlon</th>\n      <th>geometry</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>3</td>\n      <td>5</td>\n      <td>54</td>\n      <td>01779805</td>\n      <td>54</td>\n      <td>WV</td>\n      <td>West Virginia</td>\n      <td>00</td>\n      <td>G4000</td>\n      <td>A</td>\n      <td>62266456923</td>\n      <td>489045863</td>\n      <td>+38.6472854</td>\n      <td>-080.6183274</td>\n      <td>POLYGON ((-77.75438 39.33346, -77.75422 39.333...</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>3</td>\n      <td>5</td>\n      <td>12</td>\n      <td>00294478</td>\n      <td>12</td>\n      <td>FL</td>\n      <td>Florida</td>\n      <td>00</td>\n      <td>G4000</td>\n      <td>A</td>\n      <td>138962819934</td>\n      <td>45971472526</td>\n      <td>+28.3989775</td>\n      <td>-082.5143005</td>\n      <td>MULTIPOLYGON (((-83.10874 24.62949, -83.10711 ...</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>3</td>\n      <td>17</td>\n      <td>01779784</td>\n      <td>17</td>\n      <td>IL</td>\n      <td>Illinois</td>\n      <td>00</td>\n      <td>G4000</td>\n      <td>A</td>\n      <td>143778515726</td>\n      <td>6216539665</td>\n      <td>+40.1028754</td>\n      <td>-089.1526108</td>\n      <td>POLYGON ((-87.89243 38.28285, -87.89334 38.282...</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nand obtain some preliminary geospatial information about the states geodataframe:\n\n::: {#73f6fbb2 .cell execution_count=10}\n``` {.python .cell-code}\nprint(states.crs)\nstates.plot()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEPSG:4269\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](lesson-11-csv-to-geo_files/figure-html/cell-11-output-2.png){width=566 height=183}\n:::\n:::\n\n\n## `for` loops\n\n It can be easier to work with the codes as numbers instead of strings, so let's update the corresponding columns in the states geo-dataframe. We start by checking the data type of the `region`, `division`, and `statefp` columns:\n\n::: {#f458197a .cell execution_count=11}\n``` {.python .cell-code}\n code_cols = ['region', 'division', 'statefp']\n\n# Check whether codes columns are strings\n for column in code_cols: \n    print(f\"{column} is string dtype? {is_string_dtype(states[column])}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nregion is string dtype? True\ndivision is string dtype? True\nstatefp is string dtype? True\n```\n:::\n:::\n\n\nRemember `for` loops execute a block of code a fixed number of times, iterating over a set of objects. In this case, we iterate over the list of column names `code_cols = ['region', 'division', 'statefp']`.\n\n:::{.callout-caution}\n## DRY code\nWe could have checked whether all the `region`, `division`, and `statefp` columns were of string data type by using the following code:\n\n```python\nprint(f\"region is string dtype? {is_string_dtype(states['region'])}\")\nprint(f\"division is string dtype? {is_string_dtype(states['division'])}\")\nprint(f\"statefp is string dtype? {is_string_dtype(states['statefp'])}\")\n```\nHowever, this is inconvenient as it repeats the same pieces of code, only changing the column name. Instead, using the `for` loop allows us to succintly print the same information:\n```python\ncode_cols = ['region', 'division', 'statefp']\n\nfor column in code_cols: \n    print(f\"{column} is string dtype? {is_string_dtype(states[column])}\")\n```\n**Don't Repeat Yourself (DRY)** is a core programming principle that encourages  reducing redundancy and consolidating repeated logic. Try implementing it as much as possible! If you need to repeat the \"same\" code more than twice, you likely need a `for` loop.\n:::\n\n## `assert`\nNext, we update the data type of the code columns to be integers. This time, we check the data type of the column using the `is_numeric_dtype()` function inside an **`assert`** statement:\n\n::: {#7271685c .cell execution_count=12}\n``` {.python .cell-code}\n# Update code columns into integers\nfor column in code_cols:\n    states[column] = states[column].astype('int')\n    assert is_numeric_dtype(states[column])  # Check conversion\n```\n:::\n\n\nThe `assert` keyword does nothing if the expression next to it evaluates to `True` and raises an `AssertionError` exception and stops your code form running any further. For example, \n\n::: {#947b5070 .cell execution_count=13}\n``` {.python .cell-code}\n# Does nothing if statement is True\nassert 2+2 == 4\n\n# Raises an error if statement is False\nassert 2+2 == 3\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">AssertionError</span>                            Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[13], line 5</span>\n<span class=\"ansi-green-fg ansi-bold\">      2</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">assert</span> <span style=\"color:rgb(98,98,98)\">2</span><span style=\"color:rgb(98,98,98)\">+</span><span style=\"color:rgb(98,98,98)\">2</span> <span style=\"color:rgb(98,98,98)\">==</span> <span style=\"color:rgb(98,98,98)\">4</span>\n<span class=\"ansi-green-fg ansi-bold\">      4</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># Raises an error if statement is False</span>\n<span class=\"ansi-green-fg\">----&gt; 5</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">assert</span> <span style=\"color:rgb(98,98,98)\">2</span><span style=\"color:rgb(98,98,98)\">+</span><span style=\"color:rgb(98,98,98)\">2</span> <span style=\"color:rgb(98,98,98)\">==</span> <span style=\"color:rgb(98,98,98)\">3</span>\n\n<span class=\"ansi-red-fg\">AssertionError</span>: </pre>\n```\n:::\n\n:::\n:::\n\n\nIn our data type conversion code, since no `AssertionError` was raised, we can be confident that the data type was updated. \n\n## Data selection\n\nFor this lesson, we want to use only the contiguous states. As seen in the plot, the data covers a bigger extension. \n\n:::{.callout-tip}\n## Check-in\nFrom the TIGER shapefiles metadata we know that:\n \n> In addition to the fifty states, the Census Bureau treats the District of Columbia, Puerto Rico, and the Island areas (American Samoa, the Commonwealth of the Northern Mariana Islands, Guam, and the U.S. Virgin Islands) as statistical equivalents of states for the purpose of data presentation. \n\nIn [this US Census Bureau file](https://www2.census.gov/geo/pdfs/maps-data/maps/reference/us_regdiv.pdf) we can see what each code for the region, division, and state corresponds to. \n\n- What are the unique values for region, division, or state codes in the data?\n- Which codes should should we select to keep only states in the contiguous US?\n\n<!--\n States correspond to regions 1 through 4. \n However, there's also a region code 9.\n Hawaii = state code 15\n Alaska = satate code 02\n Need to exclude: region code 9 ans state codes 15 and 02\n -->\n:::\n\nLet's go ahead and select the data:\n\n::: {#6ed97eaa .cell execution_count=14}\n``` {.python .cell-code}\n# Select contiguous US states\ncontiguous = states[(states.region!=9) & (~states.statefp.isin([2,15]))]\n```\n:::\n\n\nIn this code we used the syntax \n```python\n~df.column.isin([val1, val2, val3])\n```\nThe `~` tilde symbol is used in Python to negate a statement. \nSo the previous line could be read as \"the values in `df`'s column which are *not* in the list `[val1, val2, val3]`.\"\n\n::: {.callout-tip}\n## Check-in\nSelect the data in the `power_plants` data frame for the contiguous US states. \n<!--\n\n::: {#d859c2bc .cell execution_count=15}\n``` {.python .cell-code}\npower_plants = power_plants[~power_plants.state.isin(['Puerto Rico','Hawaii','Alaska'])]\n```\n:::\n\n\n-->\n:::\n\n## Plotting\n\nBefore we plot our data, let's make sure they are in the same CRS:\n\n::: {#5a9bc981 .cell execution_count=16}\n``` {.python .cell-code}\ncontiguous.crs == power_plants.crs\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#33ad2a8e .cell execution_count=17}\n``` {.python .cell-code code-fold=\"true\"}\nfig, ax = plt.subplots(figsize=(9, 5)) # Update figure size\n\n# Remove the axis for a cleaner map\nax.axis('off')\n\n# Title for the plot\nax.set_title('Operable electric generating plants in the contiguous United States', \n              fontsize=15)\n\n# Add states\ncontiguous.plot(ax=ax,\n               color='none',\n               edgecolor='#362312')\n\n# Add electric power plants colored by energy source\npower_plants.plot(ax=ax, \n                  column='primsource',\n                  legend=True,\n                  markersize=4,\n                  cmap='tab20',\n                  alpha=0.5,\n                  legend_kwds={\n                      'title': 'Primary energy source',\n                      'title_fontsize': 'small',\n                      'fontsize': 'small',\n                      'loc': 'upper left',\n                      'bbox_to_anchor': (0, 0),\n                      'ncol': 6  \n                  })\n                  \nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/galaz-garcia/opt/anaconda3/envs/mpc-env/lib/python3.11/site-packages/geopandas/plotting.py:732: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n  if pd.api.types.is_categorical_dtype(values.dtype):\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](lesson-11-csv-to-geo_files/figure-html/cell-18-output-2.png){width=698 height=463}\n:::\n:::\n\n\nIn the map above we specified the figure size when creating the plot. This size is given in inches, but [can be updated to other units](https://matplotlib.org/stable/gallery/subplots_axes_and_figures/figure_size_units.html) (pixels, cm, etc). \n\nWe also controlled the legend location using `loc` and `bbox_to_anchor` in the `legend_kwds`:\n\n- `loc` indicates the corner of the legend we want to use for placement, and\n- `bbox_to_anchor` is a tuple with coordinates indicating where to place the corner specified in `loc` relative to the axes. Values between 0 and 1 are within the axes.\n\n<!--TODO: add diagram of bbox-->\n\n`matplotlib` uses a variety of ways to locate elements within the graph and it is best to check the documentation to not spend too much time fidling with locations.\n\n<!--\n\nhttps://www.flexprojector.com\n\nhttps://www.earthdatascience.org/courses/scientists-guide-to-plotting-data-in-python/plot-spatial-data/customize-vector-plots/python-customize-map-legends-geopandas/\n\nhttps://stackoverflow.com/questions/74143732/customize-legend-labels-in-geopandas\n-->\n\n## `for` with `zip`\n\nOften, we need to iterate simultaneously over two lists (or other iterables). \nThe `zip()` function in Python allows you to combine two or more lists (or other iterables) so that you can iterate over their elements in pairs. When used with a `for` loop, it lets you process elements from each list together, like this example:\n\n::: {#51d0bf60 .cell execution_count=18}\n``` {.python .cell-code}\n# Iterate over a single list\nnumbers = [1, 2, 3]\nfor num in numbers:\n    print(num)\n\nprint('\\n')  # Blank line\n\n# Iterate over two lists in pairs using zip()\nletters = ['a', 'b', 'c']\nfor num, letter in zip(numbers, letters):\n    print(num, letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n\n\n1 a\n2 b\n3 c\n```\n:::\n:::\n\n\nLet's see a practical application of `for` loops and `zip()` with `matplotlib` subplots. A common situation when code gets repeated is when creating subplots. For example:\n\n::: {#38d15443 .cell execution_count=19}\n``` {.python .cell-code}\nfig, axes = plt.subplots(nrows=1, ncols=3, figsize=(7, 3))\n\naxes[0].set_title('This is axis 0')\naxes[1].set_title('This is axis 1')\naxes[2].set_title('This is axis 2')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](lesson-11-csv-to-geo_files/figure-html/cell-20-output-1.png){width=581 height=283}\n:::\n:::\n\n\nIn this example, notice that the `axes` variable returned by the `plt.subplots()` function is actually an array of axes we can iterate over. Remember that the figure and the axes are separete elements in a `matplotlib` plot.\n\n![Image source: [Getting Started with Matplotlib](https://www.skytowner.com/explore/getting_started_with_matplotlib)](/book/images/lesson-10/matplotlib_figure_axes_axis.png)\n\n:::{.callout-tip}\n## Check-in\nUse `for` and `zip()` to create the same subplots and avoid redundancy.\n<!--\n```python\nfig, axes = plt.subplots(nrows=1, ncols=3, figsize=(7, 3))\nfor ax, i in zip(axes, [0,1,2]):\n    ax.set_title(f'This is axis {i}')\nplt.show()\n```\n-->\n:::\n\n:::{.callout-tip}\n## Exercise\n1. Select the power plants in California in a variable named `ca_power_plants`.\n\n2. Create a _list_ named `top_sources` with California's top 3 electric primary sources.\n\n3. Isolate the California state boundary in a variable named `ca_boundary`.\n\n4. Recreate the following plot:\n\n::: {#ed943058 .cell execution_count=20}\n\n::: {.cell-output .cell-output-display}\n![](lesson-11-csv-to-geo_files/figure-html/cell-21-output-1.png){width=566 height=272}\n:::\n:::\n\n\n:::\n\n## Functions\n\nNext, we want to keep exploring these maps of the top 3 electric primary sources for different states. This is a scenario where creating functions can be useful. In Python, **functions** are blocks of reusable code designed to perform specific tasks, helping to make your code more modular and organized. The general syntax for defining a function is the following:\n\n```python\ndef function_name(parameter_1, ..., parameter_n):\n    \"\"\"Docstring\"\"\"\n    <body of the function>\n    return value  # Depending on the function\n```\n\nWe define a function using:\n\n 1. the `def` keyword, followed by the function name, parentheses (which can contain parameters), and a colon. \n 2. The first line(s) of the function should be a `docstring`, this is a special kind of comment used to describe what the function will do. It must be indented and in between triple quotes `\"\"\"`. \n 2. After the docstring, you write the body of the function, this is the code that will be executed when the function is called. The wholek body of the function should be indentated to indicate the function's scope.\n 3. The `return` keywork is used to allow the function to return values. Functions that do not return any values don't need to have a `return` keyword.\n\n Let's see two simple examples just to get familiar with the syntax. In the first one we have a simple function with a one-line docstring, no parameters, and no return values. \n\n ```python\n def greet():\n    \"\"\"Print a greeting message.\"\"\"\n    print(\"Hello, welcome to the class!\")\n ```\n\n The second one has a single parameter and a more detailed docstring with information abou the arguments and return values. \n\n ```python\n def calculate_area(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    \n    Args:\n        radius (float): The radius of the circle.\n        \n    Returns:\n        float: The area of the circle, calculated as π * radius^2.\n    \"\"\"\n    area = 3.14159 * radius ** 2\n    return area\n ```\n\n#### Example\n\nGoing back to our power plants data frame, let's create a function that will give us the top 3 primary energy sources for a given state:\n\n::: {#eb7e3901 .cell execution_count=21}\n``` {.python .cell-code}\ndef top3_sources(state, power_plants):\n    \"\"\"\n    Find the top 3 electric primary sources of given state.\n    \n    Args:\n        state (str): The US state we want information about.\n        power_plants (pd.DataFrame): DataFrame containing data \n        on power plants, with at least 'state' and 'primsource' columns.\n    Returns:\n        list: A list of the top 3 primary sources of the state within the power_plants data frame.\n    \"\"\"\n    state_power_plants = power_plants[power_plants['state']==state]\n    top_sources = (state_power_plants['primsource']\n                                .value_counts()\n                                .index[:3]\n                                .tolist()\n                                )\n    return top_sources\n```\n:::\n\n\nWe may now reuse this function as much as we want!\n\n::: {#b1cbe98e .cell execution_count=22}\n``` {.python .cell-code}\nprint('Top 3 primary energy sources in Division 2 states:')\nfor state in ['New Jersey', 'New York', 'Pennsylvania']:\n    print(state, ': ', top3_sources(state, power_plants))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTop 3 primary energy sources in Division 2 states:\nNew Jersey :  ['solar', 'natural gas', 'biomass']\nNew York :  ['solar', 'hydroelectric', 'natural gas']\nPennsylvania :  ['natural gas', 'solar', 'biomass']\n```\n:::\n:::\n\n\nLet's do one more example and create a function that will produce a plot given a list of primary sources and a state name:\n\n::: {#d9a18a1e .cell execution_count=23}\n``` {.python .cell-code}\ndef plot_3_energy_sources(state, sources, power_plants):\n    \n    # Raise error if there are more than three sources\n    assert len(sources) == 3, 'sources must have three elements to produce the plot'\n\n    # Isolate the state boundary and power plants\n    boundary = states[states.name==state]\n    state_power_plants = power_plants[power_plants['state']==state]\n\n    # Create plot\n    fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(6, 3))\n\n    for ax, source in zip(axes, sources):\n        boundary.plot(ax=ax,                \n                      color='none',\n                      edgecolor='#362312')\n        subset = state_power_plants[state_power_plants['primsource'] == source]\n        subset.plot(ax=ax, markersize=5, alpha=0.5)\n        ax.set_title(source)\n        ax.axis('off')  # Remove axes for a cleaner look\n\n    plt.suptitle(f\"Top 3 energy sources for electric power plants in {state}\")\n    plt.tight_layout()\n    plt.show()\n```\n:::\n\n\nWe can now use our functions to produce plots for any state:\n\n::: {#8e154f62 .cell execution_count=24}\n``` {.python .cell-code}\nplot_3_energy_sources('New Jersey', \n                         top3_sources('New Jersey', power_plants),\n                         power_plants)\n```\n\n::: {.cell-output .cell-output-display}\n![](lesson-11-csv-to-geo_files/figure-html/cell-25-output-1.png){width=502 height=287}\n:::\n:::\n\n\nWriting functions can feel challenging at first, but with practice, they’ll start to come naturally whenever you find yourself reusing blocks of code. Keep experimenting and practicing—it gets easier with each function you write!\n\n<!--\nAs you go forward, some tips that can help you write them are:\n\n- crate the code for a single \n-->\n\n:::{.callout-tip}\n## Exercise\n\nWrite a function `states_with_source` that takes a primary energy source (e.g., 'solar') and returns a _list_ of states that use that source. \n\n<!--\n```python\ndef states_with_source(source_type, power_plants):\n    \"\"\"\n    Find the list of states that use a given primary energy source.\n    \n    Args:\n        source_type (str): The primary energy source (e.g., 'Coal').\n        power_plants (pd.DataFrame): DataFrame containing power plant data \n                                     with 'state' and 'primsource' columns.\n    \n    Returns:\n        list: A list of unique states where the specified energy source is used.\n    \"\"\"\n    # Filter the DataFrame for rows where 'primsource' matches the specified source_type\n    source_power_plants = power_plants[power_plants['primsource'] == source_type]\n    \n    # Get a list of unique states from the filtered DataFrame\n    states = source_power_plants['state'].unique().tolist()\n    \n    return states\n```\n-->\n:::\n\n",
    "supporting": [
      "lesson-11-csv-to-geo_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}