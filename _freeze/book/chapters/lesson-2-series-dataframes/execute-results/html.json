{
  "hash": "62e298eedafbfcfa8c540a4fefa472b0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntoc-title: In this lesson\nfig-cap-location: margin\n---\n\n\n\n\n# `pandas` series and data frames\n\nIn this lesson we introduce the two core objects in the `pandas` library, the `pandas.Series` and the `pandas.DataFrame`. \nThe overall goal is to gain familiarity with these two objects, understand their relation to each other, and review Python data structures such as dictionaries and lists.\n\n## Learning objectives \nBy the end of this unit, students will be able to:\n\n- Explain the relation between `pandas.Series` and `pandas.DataFrame`\n- Construct simple `pandas.Series` and `pandas.DataFrame` from scratch using different initalization methods \n- Identify and modify the index in a `pandas.Series` or `pandas.DataFrame`\n- Navigate the `pandas` documentation to look for attributes and methods of `pandas.series` and `pandas.DataFrame`\n\n## `pandas`\n\n`pandas` @reback2020pandas @mckinney-proc-scipy-2010 is a Python package to wrangle and analyze tabular data. It is built on top of NumPy and has become the core tool for doing data analysis in Python. \n\nThe standard abbreviation for `pandas` is `pd`. Here we will import it together with NumPy:\n\n::: {#cf4c4f02 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n```\n:::\n\n\n::: {.callout-caution}\n## Convention: importing packages\nAlways import all your packages in a single cell at the top of you notebook! Following the [PEP 8 - Style Guide for Python Code](https://peps.python.org/pep-0008/#imports) @pep8, each package or library import should be in a separate line. \n:::\n<!--\nThere is so much to learn about `pandas`. While we won't be able to cover every single functionality of this package in the next three lecutres, the goal is to get you started with the basic tools for data wrangling and give you a solid basis on which you can explore further. \n-->\n## Series\n\nThe first core object of pandas is the **series**. \nA series is a *one-dimensional* array of *indexed* data. \n\n![Image adapted from [Introduction to GeoPandas.](https://geopandas.org/en/stable/getting_started/introduction.html)](/book/images/lesson-2/series-diagram.png){width=30%}\n\nA `pandas.Series` having an **index** is the main difference between a `pandas.Series` and a NumPy array. Let's see the difference:\n\n::: {#3243ea39 .cell execution_count=2}\n``` {.python .cell-code}\n# a numpy array\narr = np.random.randn(4) # random values from std normal distribution\nprint(type(arr))\nprint(arr, \"\\n\")\n\n# a pandas series made from the previous array\ns = pd.Series(arr)\nprint(type(s))\nprint(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'numpy.ndarray'>\n[-1.03786641 -0.79527582  1.38205387 -0.14540007] \n\n<class 'pandas.core.series.Series'>\n0   -1.037866\n1   -0.795276\n2    1.382054\n3   -0.145400\ndtype: float64\n```\n:::\n:::\n\n\nNotice the index is printed as part of the `pandas.Series` while, although the `np.array` is indexable, the index is not part of this data structure. Printing the `pandas.Series` also shows the values and their data type.\n\n![](/book/images/lesson-2/series-parts.png){width=80%}\n\n### Creating a `pandas.Series`\n\nThe basic method to create a `pandas.Series` is to call\n\n``` python\ns = pd.Series(data, index=index)\n```\n\nThe `data` parameter can be:\n\n- a list or NumPy array,\n- a Python dictionary, or \n- a single number, boolean (`True`/`False`), or string.\n\nThe `index` parameter is optional, if we wish to include it, it must be a list of list of indices of the same length as data. \n\n#### Example: Creating a `pandas.Series` from a NumPy array\nLet's create a `pandas.Series` from a NumPy array. To use this method we need to pass a NumPy array (or a list of objects that can be converted to NumPy types) as `data`. Here, we will also include the list `[2023, 2024, 2025]` to be used as an index:\n\n::: {#62cebd4b .cell execution_count=3}\n``` {.python .cell-code}\n# a series from a numpy array \npd.Series(np.arange(3), index=[2023, 2024, 2025])\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n2023    0\n2024    1\n2025    2\ndtype: int64\n```\n:::\n:::\n\n\n#### Example: Creating a `pandas.Series` from a list\n Here we create a `pandas.Series` from a list of strings. Remember that the `index` parameter is optional. If we don't include it, the default is to make the index equal to `[0,...,len(data)-1]`. For example:\n\n::: {#887b27be .cell execution_count=4}\n``` {.python .cell-code}\n# a series from a list of strings with default index\npd.Series(['EDS 220', 'EDS 222', 'EDS 223', 'EDS 242'])\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0    EDS 220\n1    EDS 222\n2    EDS 223\n3    EDS 242\ndtype: object\n```\n:::\n:::\n\n\n#### Example: Creating a `pandas.Series` from a dictionary\nRecall that a dictionary is a set of key-value pairs. If we create a `pandas.Series` via a dictionary the keys will become the index and the values the corresponding data.\n\n::: {#6813315a .cell execution_count=5}\n``` {.python .cell-code}\n# construct dictionary\nd = {'key_0':2, 'key_1':'3', 'key_2':5}\n\n# initialize series using a dictionary\npd.Series(d)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nkey_0    2\nkey_1    3\nkey_2    5\ndtype: object\n```\n:::\n:::\n\n\n:::{.callout-note}\n## `dtype: object`\nNotice that in this and the previous example the data type of the values in the series is `object`. This data type in `pandas` *usually* indicates that the series is made up of strings. However, we can see in this example that the `object` data type can also indicate a mix of strings *and* numbers. \n:::\n\n#### Example: Creating a `pandas.Series` from a single value\nIf we only provide a single number, boolean, or string as the data for the series, we need to provide an index. The value will be repeated to match the length of the index. Here, we create a series from a single float number with an index given by a list of strings:\n\n::: {#3eb64041 .cell execution_count=6}\n``` {.python .cell-code}\npd.Series(3.0, index = ['A', 'B', 'C'])\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nA    3.0\nB    3.0\nC    3.0\ndtype: float64\n```\n:::\n:::\n\n\n### Simple operations\n\nArithmetic operations work on series and so most NumPy functions. For example:\n\n::: {#eaa847d3 .cell execution_count=7}\n``` {.python .cell-code}\n# define a series\ns = pd.Series([98,73,65],index=['Andrea', 'Beth', 'Carolina'])\n\n# divide each element in series by 10\nprint(s /10, '\\n')\n\n# take the exponential of each element in series\nprint(np.exp(s), '\\n')\n\n# original series is unchanged\nprint(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAndrea      9.8\nBeth        7.3\nCarolina    6.5\ndtype: float64 \n\nAndrea      3.637971e+42\nBeth        5.052394e+31\nCarolina    1.694889e+28\ndtype: float64 \n\nAndrea      98\nBeth        73\nCarolina    65\ndtype: int64\n```\n:::\n:::\n\n\nWe can also produce new `pandas.Series` with `True`/`False` values indicating whether the elements in a series satisfy a condition or not:\n\n::: {#9146538c .cell execution_count=8}\n``` {.python .cell-code}\ns > 70\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nAndrea       True\nBeth         True\nCarolina    False\ndtype: bool\n```\n:::\n:::\n\n\nThis kind of simple conditions on `pandas.Series` will be key when we are selecting data from data frames.\n\n### Identifying missing values\nIn `pandas` we can represent a missing, NULL, or NA value with the float value `numpy.nan`, which stands for \"not a number\". Let's construct a small series with some NA values represented this way:\n\n::: {#a8a09511 .cell execution_count=9}\n``` {.python .cell-code}\n# series with NAs in it\ns = pd.Series([1, 2, np.nan, 4, np.nan])\ns\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n0    1.0\n1    2.0\n2    NaN\n3    4.0\n4    NaN\ndtype: float64\n```\n:::\n:::\n\n\nNotice the data type of the values it he series is still `float64`. \n\nThe [`hasnans` attribute](https://pandas.pydata.org/docs/reference/api/pandas.Series.hasnans.html) for a `pandas.Series` returns `True` if there are any NA values in it and false otherwise:\n\n::: {#02b6b867 .cell execution_count=10}\n``` {.python .cell-code}\n# check if series has NAs\ns.hasnans\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nTrue\n```\n:::\n:::\n\n\nAfter detecting there are Na values, we might be intersted in knowing which elements in the series are NAs. We can do this using the [`isna` method](https://pandas.pydata.org/docs/reference/api/pandas.Series.isna.html):\n\n::: {#acbf653c .cell execution_count=11}\n``` {.python .cell-code}\ns.isna()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n0    False\n1    False\n2     True\n3    False\n4     True\ndtype: bool\n```\n:::\n:::\n\n\nThe ouput is a `pandas.Series` of boolean values indicating if an element in the row at the given index is `np.nan` (`True` = is NA) or not (`False` = not NA).\n\n:::{.callout-tip}\n## Check-in\n\n1. The integer number -999 is often used to represent missing values. Create a `pandas.Series` named `s` with four integer values, two of which are -999. The index of this series should be the the letters A through D.\n\n<!--\n\n::: {#333df34b .cell execution_count=12}\n``` {.python .cell-code}\ns = pd.Series([10,10, -999, - 999], index= ['A','B','C','D'])\ns\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nA     10\nB     10\nC   -999\nD   -999\ndtype: int64\n```\n:::\n:::\n\n\n-->\n\n2. In the [`pandas.Series` documentation](https://pandas.pydata.org/docs/reference/api/pandas.Series.html), look for the method `mask()`. Use this method to update the series `s` so that the -999 values are replaced by NA values. HINT: check the first example in the method's documentation.\n\n<!--\n\n::: {#a3f9eb9e .cell execution_count=13}\n``` {.python .cell-code}\ns = s.mask(s == -999)\ns\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nA    10.0\nB    10.0\nC     NaN\nD     NaN\ndtype: float64\n```\n:::\n:::\n\n\n-->\n:::\n\nThere's *much* more to say about `pandas.Series`, but this is enough to get us going. At this point, we mainly want to know about `pandas.Series` because `pandas.Series` are the columns of a `pandas.DataFrame`.\n\n<!--\n::: {.callout-caution}\n## slicing with `loc`\nNotice that when use slicing with `loc` we get both the start *and the end* of the indices we indicated. This is different to slicing in numpy arrays or lists where we do not get the element at the end of the slice. Compare the following:\n\n::: {#792939a2 .cell execution_count=14}\n``` {.python .cell-code}\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(x)\n\n# slicing will return elements at indices 2 trhough 4 (inclusive)\nx[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n[2, 3, 4]\n```\n:::\n:::\n\n\n::: {#769ffefd .cell execution_count=15}\n``` {.python .cell-code}\n# define a np array with integers from 0 to 9\ny = np.arange(10)\nprint(y)\n\n# slicing will return elements at indices 2 trhough 4 (inclusive)\ny[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5 6 7 8 9]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray([2, 3, 4])\n```\n:::\n:::\n\n\n::: {#efdd9cdf .cell execution_count=16}\n``` {.python .cell-code}\n z = pd.Series(y)\n print(z)\n\n# slicing will return elements with index labels 2 through 5 (inclusive)\n z.loc[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    0\n1    1\n2    2\n3    3\n4    4\n5    5\n6    6\n7    7\n8    8\n9    9\ndtype: int64\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n2    2\n3    3\n4    4\n5    5\ndtype: int64\n```\n:::\n:::\n\n\n::: \n-->\n\n## Data frames\n\nThe `pandas.DataFrame` is the most used `pandas` object. It represents tabular data and we can think of it as a spreadhseet. Each column of a `pandas.DataFrame` is a `pandas.Series`. \n\n![Image adapted from [Introduction to GeoPandas.](https://geopandas.org/en/stable/getting_started/introduction.html)](/book/images/lesson-2/data-frame-diagram.png){width=65%}\n\n### Creating a `pandas.DataFrame`\nThere are [many ways of creating a `pandas.DataFrame`](https://pandas.pydata.org/docs/user_guide/dsintro.html#dataframe). We present one simple one in this section. \n\nWe already mentioned each column of a `pandas.DataFrame` is a `pandas.Series`. In fact, the `pandas.DataFrame` is a dictionary of `pandas.Series`, with each column name being the key and the column values being the key's value. Thus, we can create a `pandas.DataFrame` in this way:\n\n::: {#fd442567 .cell execution_count=17}\n``` {.python .cell-code}\n# initialize dictionary with columns' data \nd = {'col_name_1' : pd.Series(np.arange(3)),\n     'col_name_2' : pd.Series([3.1, 3.2, 3.3]),\n     }\n\n# create data frame\ndf = pd.DataFrame(d)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>col_name_1</th>\n      <th>col_name_2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>3.1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>3.2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>3.3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can change the index by changing the `index` attribute in the data frame:\n\n::: {#f029206c .cell execution_count=18}\n``` {.python .cell-code}\n# change index\ndf.index = ['a','b','c']\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>col_name_1</th>\n      <th>col_name_2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>a</th>\n      <td>0</td>\n      <td>3.1</td>\n    </tr>\n    <tr>\n      <th>b</th>\n      <td>1</td>\n      <td>3.2</td>\n    </tr>\n    <tr>\n      <th>c</th>\n      <td>2</td>\n      <td>3.3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n:::{.callout-tip}\n## Check-in\nWe can access the data frame's column names via teh [`columns` attribute](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.columns.html#pandas.DataFrame.columns). Update the column names to C1 and C2 by updating the `columns` attribute.\n:::\n\n<!--\n\n::: {#5c3958f5 .cell execution_count=19}\n``` {.python .cell-code}\n# print original column names\nprint(df.columns)\n\n# change column names \ndf.columns = ['C1','C2']\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex(['col_name_1', 'col_name_2'], dtype='object')\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>C1</th>\n      <th>C2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>a</th>\n      <td>0</td>\n      <td>3.1</td>\n    </tr>\n    <tr>\n      <th>b</th>\n      <td>1</td>\n      <td>3.2</td>\n    </tr>\n    <tr>\n      <th>c</th>\n      <td>2</td>\n      <td>3.3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n-->\n\n## Next\n\nJump to the week 1 discussion section to practice preliminary data exploration with a real world dataset. Then, continue with the next lesson on subsetting data frames.\n\n",
    "supporting": [
      "lesson-2-series-dataframes_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}