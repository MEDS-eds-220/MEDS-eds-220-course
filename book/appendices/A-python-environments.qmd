---
toc-title: In this lesson
notes: https://docs.google.com/document/d/1emJIWWFXeXqKbX-oWd3uL-jBsGmT7tEuJLtm_A2F3rQ/edit
slides: https://docs.google.com/presentation/d/1sNrtPFILwtN4xzkAEyjAcCwGKs4wbhQZAifk-phuXDo/edit?usp=sharing
---

# Virtual environments

This hands-on lesson gives a brief introduction to Python virtual environments.

## Learning objectives
By the end of this lesson, students will be able to:

- Describe what Conda environments are and how they are used to install Python packages
- Use standard Conda commands to list, activate, deactivate, create, and delete environments 
- Build Conda environments and install packages using the command line
- Generate a .yml file with environment specifications

## Environments: what and why

Environments are a way to keep the packages and Python versions you use for different projects organized. 

![Some environments can have lots of packages and dependencies, while others can keep it simple. ](/book/appendices/images/appendix-A/project-cats.png){width=60% fig-align="center"}

The main reasons to create an environment for each of your projects are:

- To not interfere with your computerâ€™s pre-installed Python
- Packages usually depend on other packages to work properly, this is called a **package dependency**. Dependencies across different packages need to be carefully managed and may potentially be different across projects.
- Reproducibility! Being able to share your code and what it needs to run it with others

## Conda environments

[Conda](https://conda.org) is an environment *and* package management system: 
it can both create and administer the environments *and* install compatible versions of software and their dependencies within an environment. 

Environments created with Conda are usually called **Conda environments**. A Conda environment doesn't need to be a Python environment, Conda can manage packages for any programming language. 

![](/book/appendices/images/appendix-A/conda-logo.png){width=45% fig-align="center"}

## Conda channels

**Conda channels** are the remote locations where packages are stored. Think of them as shops for getting packages.
By default, packages are downloaded to your computer and updated from the [conda default channel](https://repo.anaconda.com/pkgs/). But there are others! [Conda-forge](https://conda-forge.org) and [bioconda](https://bioconda.github.io) are two popular ones.
We can choose which Conda channel to install a package from. 

## `pip`

`pip` is a *package* management system *only* for Python. We can use it to install packages from the [Python Package Index (PyPI)](https://pypi.org). We can use `pip` inside a Conda environment when a package is not available from a Conda channel.

![](/book/appendices/images/appendix-A/pip-logo.png){width=45% fig-align="center"}

## Conda commands

https://conda.io/projects/conda/en/latest/user-guide/cheatsheet.html

| Command | What it does |
|:---------|:-----| 
| `conda env list`     | list available Conda environments |
| `conda create --name my-env python` | create new Python environment called `my-env` |
| `conda remove --name my-env  --all` | delete `my-env` |
| `conda activate my-env` | activate environment |
| `conda deactivate` | deactivate active environment|
| `python -V` | check which Python version is installed in active environment | 
| `conda list` | check which packages are installed in active environment | 
| `conda list numpy` | check if `numpy` is installed in active environment | 
| `conda install numpy` | install `numpy` package in environment using environment channel priorities (generally just from defaults channel)| 
| `conda install --channel conda-forge rioxarray` | install `rioxarray ` package in environment from from conda-forge channel (after going through other environment channel prioirities) |

## Hands-on environments

### 1. List environments

To list all the Conda environments available in your computer and their location we use:

```default
conda env list
```
The output should look something like this:
```default
# conda environments:
#
base                  *  /Users/galaz-garcia/opt/anaconda3
eds220-env               /Users/galaz-garcia/opt/anaconda3/envs/eds220-env
```

 Notice the file path next to the environment name. This is the absolute path to the environment's installation directory on my local machine. This is where Conda has created the environment and stored the packages!

**What is my currently active environment?**

- When you run `conda env list`, the **asterisk next to the environment path indicates which environment is active**. In the previous example, I am using the base Python environment. 
- The currently active environment also appears in the terminal in parenthesis at the beginning of each line, something like this:

```default
(base) my-computer:MEDS-eds-220-course galaz-garcia$
```

### 2. Create new Python environment

To create a new environment called `test-env` and, within it, install the most recent version of Python we simply run: 

```default
conda create --name test-env python
```
When you run this command, it will print out information about the packages that will be installed and ask you whether to proceed or not. Type `y` and press enter to create the environment and install the packages.

::: {.callout-tip}
## Check-in
Check whether the new `test-env` environment is listed by Conda. Is it activated or not?
:::

### 3. Activate environment

To activate the `test-env` environment we use the command
```default
conda activate test-env
```

::: {.callout-tip}
## Check-in
Verify that `test-env` is now your current environment.
:::

### 4. Packages information
To see which packages are installed within the currently active environment we run:
```default
conda list
```
The output will be a long list that looks something like this:
```default
# packages in environment at /Users/galaz-garcia/opt/anaconda3/envs/test-env:
#
# Name                    Version                   Build  Channel
bzip2                     1.0.8                h6c40b1e_6  
pip                       24.2            py312hecd8cb5_0  
sqlite                    3.45.3               h6c40b1e_0  
[...]
```

The **name and version** of each installed package in the environment appear in their respective columns. The 'Build' column shows a **build string** for each package. This string encodes important information about how the package was compiled, including any updates or changes made without altering the package version. It also reflects any compatibility or performance optimizations that were integrated during the build process.

For example, the same package with the same version might have different builds (and therefore different build strings) depending on whether it was installed on macOS, Windows, or Linux. This difference arises because the package may need to be compiled differently to optimize performance and ensure compatibility with each operating system.

The **channel** column shows the source from which the package was downloaded and installed. 
In this example the entries on this column are blank, signaling these packages were downloaded from the defeault Conda channel. We'll see other channels appear in the next examples.

We can also request information about a specific package. For example, if we run
```default
conda list pip
```
we obtain only the information about the `pip` package:
```default
# packages in environment at /Users/galaz-garcia/opt/anaconda3/envs/test-env:
#
# Name                    Version                   Build  Channel
pip                       24.2            py312hecd8cb5_0  
```

We can use the same command to verify whether a package is installed. For example, if we run
```default
conda list numpy
```
we will get empty columns:
```default
# packages in environment at /Users/galaz-garcia/opt/anaconda3/envs/test-env:
#
# Name                    Version                   Build  Channel
```
because the `numpy` package is not intalled in this environment.

### 5. Searching for and installing packages

Suppose we want to install `numpy` in our currently active environment `test-env`. To do this we can simply use the command:
```default
conda install numpy
```
Since we have not specified another channel, this command will install `numpy` from the default channel.

::: {.callout-tip}
## Check-in
Verify that `numpy` is now installed.
:::

Now, suppose we want to install `rioxarray`, this is a Python package for raster data analysis. This is a relatively new package, so it might not be available from the default Conda channels. 
A sensible measure would be to first look if `rioxarray` is available in the defaults channels, which we can do by running:

```default
conda search rioxarray
```
The output will look similar to
```default
Loading channels: done
No match found for: rioxarray. Search: *rioxarray*

PackagesNotFoundError: The following packages are not available from current channels:

  - rioxarray

Current channels:

  - https://repo.anaconda.com/pkgs/main/osx-64
  - https://repo.anaconda.com/pkgs/main/noarch
  - https://repo.anaconda.com/pkgs/r/osx-64
  - https://repo.anaconda.com/pkgs/r/noarch

To search for alternate channels that may provide the Conda package you're
looking for, navigate to

    https://anaconda.org

and use the search bar at the top of the page.
```
As stated, `rioxarray` is not available on the default channels for my Conda installation. Notice a couple of the channels it is seraching on are specific to macOS (my current operating system). The last two channels are actually channels for R packages. If we had tried to install `rioxarray` using `conda install rioxarray` we would have obtained an error message with similar information (you can try it if you want!).

We may have better luck searching for `rioxarray` in the conda-forge channel, which we can do like this:
```default
conda search --channel conda-forge rioxarray
```
The result will be a list of available versions and builds of this package in the conda-forge channel:
```default
Loading channels: done
# Name                       Version           Build  Channel             
rioxarray                      0.0.3            py_0  conda-forge         
rioxarray                      0.0.4            py_0  conda-forge         
rioxarray                      0.0.5            py_0  conda-forge     
[...]
rioxarray                     0.16.0    pyhd8ed1ab_0  conda-forge         
rioxarray                     0.17.0    pyhd8ed1ab_0  conda-forge   
```
::: {.callout-tip}
## Check-in
Do you see any versions of `rioxarray` with multiple builds?
:::

Since we now know that we can find `rioxarray` in the conda-forge channel, we can go ahead and install it from this channel using the command
```default
conda install --channel conda-forge rioxarray
```
You'll see a moving bar that says Conda is **solving (the) environment** - this is Conda doing its package management job! It means Conda is working on:

- finding the dependencies for the packages you are trying to install, 
- finding versions of these dependencies that are compatible with each other,
- making sure these new packages are compatible with the packages already present in the environment, 
- downgrade, upgrade, or remove packages as needed in the environment. 

Overall, Conda tries to install what we need with the least disruption. **Solving an environment can often take time** but it is crucial so that the environment remains stable and functional. 

::: {.callout-tip}
## Check-in
1. Check whether `pandas` is installed in the environment.
2. Which channels were used to install dependencies for `rioxarray`?
:::

<!--
TO DO: should add something with pip here
-->

### 6. Deactivate environment

To deactivate our current environment and return to our base environment we simply run 
```default
conda deactivate
```

::: {.callout-tip}
## Check-in
Verify we are no longer in the `test-env`. What environment are we on?
:::

### 7. Delete environment

Since this was a test environment, we can go ahead and delete all of it using the command:
```default
conda remove --name test-env  --all
```

It will ask you whether you want to proceed. Type `y` and press enter to go ahead and delete the environment. 

We can run `conda env list` to verify the `test-env` does not exist anymore. 

### 8. Create environment (one liner)

We can also create a new environment by specifying the package versions and channel priorities. For example, to install the `numpy` and `rioxarray` versions we previously had in a new environment called `my-env` we run:

```default
conda create --name my-env rioxarray=0.17.0 numpy=1.26.4 --channel conda-forge
```

Notice we are explicitely requiring certain versions of our packages, and the `--channel conda-forge` command is asking Conda to prioritize getting the packages from conda-forge. 

::: {.callout-tip}
## Check-in
Take a look at the dependencies that were installed with these two packages.
:::

### 9. Exporting an environment

One of the main goals of using an environment to manage the packages used in your project is being able to share the environment so that other people can rerun your code and reproduce your results. 

Rather than "sharing the environment", it might be better to think about sharing instructions that Conda can use to recreate the environment you have. These instructions are basically a list of the packages installed in the environment, their versions, which channels were used to install them, and, optionally, build specifications. There are several ways of doing getting these instructions depending on the level of cross-platform compatibility we are looking for.

#### Platform and package specific

The first method to export the environment specifications is
```default
conda env export > environment.yml
```

The `environment.yml` is the name 

Open the `environment.yml` file that was generated, it will look similar to this excerpt:
```default
name: my-env
channels:
  - conda-forge
  - defaults
dependencies:
  - affine=2.4.0=pyhd8ed1ab_0
  - attrs=24.2.0=pyh71513ae_0
  [...]
  - zlib=1.3.1=h87427d6_1
  - zstd=1.5.6=h915ae27_0
prefix: /Users/galaz-garcia/opt/anaconda3/envs/my-env
```

The first method we can use to export the environment specifications is the most detailed, listing the channels (in order of priority), and the package names, each with a version and build string.
