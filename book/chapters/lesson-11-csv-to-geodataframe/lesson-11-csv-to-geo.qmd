# CSV to `GeoDataFrame`

In this lesson we will learn how to extract geospatial data from a CSV to create a `geopandas.GeoDataFrame` and go over some more customizations for maps and matplotlib figures.

<!--
TODO: learning objectives
-->

## About the data

The U.S. energy landscape relies on a mix of fossil fuels and renewables, each with unique environmental and economic impacts. As the nation works toward sustainability and energy security, understanding this energy mix is essential for informed policy and progress toward cleaner energy.

In this lesson, we will use data from the U.S. [Energy Information Administration (EIA)](https://www.eia.gov) about [operable electric generating plants in the United States by energy source, as of May 2023](https://atlas.eia.gov/datasets/eia::power-plants/about). The dataset includes information on plant types and energy sources, offering insights into the diversity of power sources—from fossil fuels to renewables—that supply electricity nationwide. The dataset's metadata can be [accessed here](https://eia.maps.arcgis.com/sharing/rest/content/items/bf5c5110b1b944d299bb683cdbd02d2a/info/metadata/metadata.xml?format=default&output=html)
<!-- TODO: add citation -->
<!-- TODO: add image -->
The EIA data on electric plants has been downloaded as a CSV and reprojected into the EPSG:4269 CRS for this lesson. It can be accessed [here](https://github.com/carmengg/eds-220-book/blob/main/data/power_plants_epsg4269.csv).

<!-- TODO: column descriptions: lat lon, -->

Additionally, we will use a [TIGER shapefile of the US states from the United States Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.2022.html#list-tab-790442341). 
[TIGER](https://en.wikipedia.org/wiki/Topologically_Integrated_Geographic_Encoding_and_Referencing) stands for Topologically Integrated Geographic Encoding and Referencing. This used to be the data format the US Census distributed geospatial data, but since 2008 TIGER files are converted to shapefiles. You can view the metadata for all the TIGER shapefiles [here](https://www.census.gov/programs-surveys/geography/technical-documentation/complete-technical-documentation/tiger-geo-line.html). 

Follow these steps to download shapefile with the United States' states:

1. At the bottom of the [2022 page](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.2022.html#list-tab-790442341), under Download, click on "Web Interface"
2. For year, select 2022, and for layer type select "States (and equivalent)". Click submit. 
3. Click on "Download national file".


The column descriptions for the US states shapefile are:

![Source: TIGER/Line Shapefiles Technical Documentation](/book/images/lesson-11/tiger_shp_columns.png)


## CSV to `geopandas.GeoDataFrame`

Let's start by importing packages and updating viewing options:

```{python}
import os
import pandas as pd
import matplotlib.pyplot as plt

import geopandas as gpd

# Display all column when looking at dataframes
pd.set_option("display.max.columns", None)
```

Next, we import the power plants dataset.  In this lesson, we have downloaded the data into a `data/` folder in the same level as our notebook.

```{python}
# Import power plants data
URL = 'https://raw.githubusercontent.com/carmengg/eds-220-book/refs/heads/main/data/power_plants_epsg4269.csv'
power_plants = pd.read_csv(URL)

# Simpify column names
power_plants.columns = power_plants.columns.str.lower()

power_plants.head(3)
```

<!--TO DO: Need to drop the unnamed column--> 

The power plants file is a CSV. Unlike shapefiles or other geospatial file formats, `geopandas` doesn't have a way to extract a geometry column from a CSV file, so we will need to create this geometry manually. 

To do so we will use the longitude and latitude columns in the CSV, these indicate the location of the power plants in the NAD83 CRS (EPSG:4269).
We can use this information to create a new `geopandas.GeoDataFrame` from the `pandas.DataFrame` using the `geopandas` function [`points_from_xy()`](https://geopandas.org/en/stable/docs/reference/api/geopandas.points_from_xy.html):

```{python}
# Create points from latitude and longitude
points = gpd.points_from_xy(power_plants.longitude, 
                            power_plants.latitude)

# Create geodataframe
power_plants = gpd.GeoDataFrame(power_plants,    # Data
                                geometry=points, # Specify geometry column
                                crs='EPSG:4269'  # Specify crs
                                )
```

Let's check that we now have a `geometry` column:

```{python}
power_plants['geometry']
```

We can now also access information about the CRS of our power plants dataset:

```{python}
# Explore CRS
print('CRS: ', power_plants.crs)
print('ellipsoid: ', power_plants.crs.ellipsoid)
print('datum: ', power_plants.crs.datum)
print('is the CRS geographic?: ', power_plants.crs.is_geographic)
print('is the CRS projected?: ', power_plants.crs.is_projected)
```

With the `geometry` column and CRS, we can plot our dataset:

```{python}
power_plants.plot()
```

## Import shapefile

Let's import the TIGER shapefile
```{python}
# Import states data
fp = os.path.join('data','tl_2022_us_state','tl_2022_us_state.shp')
states = gpd.read_file(fp)

# Simplify column names
states.columns = states.columns.str.lower()

states.head(3)
```

and obtain some preliminary geospatial information about the states geodataframe:

```{python}
print(states.crs)
states.plot()
```

## Data selection
 For this lesson, we want to use only the contiguous states. As seen in the plot, the data covers a bigger extension. From the TIGER shapefiles metadata we know that:
 
 > In addition to the fifty states, the Census Bureau treats the District of Columbia, Puerto Rico, and the Island areas (American Samoa, the Commonwealth of the Northern Mariana Islands, Guam, and the U.S. Virgin Islands) as statistical equivalents of states for the purpose of data presentation. 

 In [this US Census Bureau file](https://www2.census.gov/geo/pdfs/maps-data/maps/reference/us_regdiv.pdf) we can see what each code for the region, division, and state corresponds to. 
 These should be numeric codes, so we can start by updating the corresponding columns in the states geo-dataframe:

```{python}
 # Notice region, division, and statefp are strings (object) types
 states.dtypes
```

```{python}
 # Update data types of code columns
for column in ['region', 'division', 'statefp']:
    states[column] = states[column].astype('int')

states.region = states.region.astype('int')
states.division = states.division.astype('int')
states.statefp = states.statefp.astype('int')
```

 States corresponds to regions 1 through 4. 
 However, there's also a region code 9.
 These rows correspond to non-state regions:

```{python}
print(states.region.unique())
states[states.region==9]
``` 

 We can check that Alaska and the non-state regions are causing the long map:

```{python}
# plot data in states that is not Alaska (code 2) and doesn't have region code 9
states[(states.statefp!=2) & (states.region!=9)].plot()
```

## Data selection

For the pupose of this exercise, we want to keep only data for the contiguous states.
Let's overwrite the geo-dataframes accordingly:

```{python}
states = states[(states.region!=9) & (~states.statefp.isin([2,15]))]
power_plants = power_plants[~power_plants.state.isin(['Puerto Rico','Hawaii','Alaska'])]
```

::: {.callout-tip}
## `~` = not
In the previous code we used the syntax 
```python
~df.column.isin([val1, val2, val3])
```
The `~` tilde symbol is used in Python to negate a statement. 
So the previous line could be read as "the values in df's column which are *not* in the list [val1, val2, val3]."
:::