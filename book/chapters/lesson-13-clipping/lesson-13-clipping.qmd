
<!--
Ignore ShapelyDeprecationWarning warning in render

```{python}
import shapely
import warnings
from shapely.errors import ShapelyDeprecationWarning

warnings.filterwarnings("ignore", category=ShapelyDeprecationWarning) 
```
-->

# Clipping

In this lesson we will learn how to to clip different geometries.

## About the data

We will use three datasets in this lesson. 

The first dataset is a [TIGER shapefile of the US states from the United States Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.2022.html#list-tab-790442341). Follow these steps to download shapefile with the United States' states:

1. At the bottom of the [2022 page](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.2022.html#list-tab-790442341), under Download, click on "Web Interface"
2. For year, select 2022, and for layer type select "States (and equivalent)". Click submit. 
3. Click on "Download national file".

You can check the [metadata for all the TIGER shapefiles here](https://www.census.gov/programs-surveys/geography/technical-documentation/complete-technical-documentation/tiger-geo-line.html). 
The columns for this shapefile are:

![Source: TIGER/Line Shapefiles Technical Documentation](/images/tiger_shp_columns.png)

The second dataset we'll use is [Natural Earth's simple medium scale populated places dataset](https://www.naturalearthdata.com/downloads/50m-cultural-vectors/). We can obtain this dataset by downloading the shapefile (choose the one that says "simple (less columns)").

The third dataset we'll use is [Natural Earth's road dataset](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/roads/). 
We can obtain this dataset by downloading the shapefile 

For the notes, all the data is inside a `data/` directory at the same level as the notebook. 

## Import data

Let's start by loading our libraries and then importing the datasets we will use.

```{python}
import os
import pandas as pd
import matplotlib.pyplot as plt
import geopandas as gpd

from shapely.geometry import box  # To create polygon bounding box

pd.set_option("display.max.columns", None)

# -------------------------------------
# Import and simplify states polygons
states = gpd.read_file(os.path.join('data',
                                    'tl_2022_us_state',
                                    'tl_2022_us_state.shp')
                                    )
states.columns = states.columns.str.lower()

# Import Natural Earth populated places points
places = gpd.read_file(os.path.join('data',
                                    'ne_50m_populated_places_simple',
                                    'ne_50m_populated_places_simple.shp')
                                    )

# Import ferry routes lines
roads = gpd.read_file(os.path.join('data',
                                   'ne_10m_roads',
                                   'ne_10m_roads.shp')
                                   )
```

## Prepare Alaska multipolygon

Let's start by taking taking a look at our `states` geo-dataframe. 
Since this is a geospatial dataset, exploration should include *at least* checking the head of the dataset, plotting the data, and looking at its CRS.

```{python}
print(f"CRS: {states.crs}")

states.head(3)
```

```{python}
states.plot()
```

For this lesson, we are intersted in plotting data only Alaska, se let's select this data:

```{python}
alaska = states[states.name =='Alaska']
alaska.plot()
```

Notice that the way the Alaska multipolygon is plotted under the EPSG:4269 separates the islands and unnaturally elongates the map. 
To fix this, we will reproject the Alaska geo-dataframe to the EPSG:3338 CRS. 
This CRS is a *projected* CRS, better suited for working with data from Alaska:

![Source: [spatialreference.org](https://spatialreference.org/ref/epsg/nad83-alaska-albers/) ](/images/epsg_3338.png)

```{python}
# Reproject to CRS optimized for Alaska
alaska = alaska.to_crs('epsg:3338')

# Inspect the new CRS
print('Is this CRS projected? ', alaska.crs.is_projected)
alaska.crs
```

```{python}
alaska.plot()
```

## Prepare populated places points

Let's now explore the populated places data. 

```{python}
print(f"CRS: {places.crs}")

places.head(3)
```

```{python}
places.plot()
```

This dataset has the EPSG:4326 CRS. Remember this is the EPSG code for the WGS 84 CRS. 
This is not a surprise since the places data is global and EPSG:4326/WGS84 is the most widely used CRS for such data.

Let's see what happens when we try to plot this data on top of Alaska:

```{python}
# Trouble
fig, ax = plt.subplots()

alaska.plot(ax=ax)
places.plot(ax=ax, color='red')

plt.show()
```

::: {.callout-warning}
## Data in weird places? Check your CRSs
This is a classic slip in geospatial analysis. 
To plot, analyze, or integrate different geospatial datasets they **must have the same CRS**. 

Here, `alaska` and `places` have different CRSs, leading to unexpected results when plotting them together:
```{python}
alaska.crs == places.crs
```
:::

:::{.callout-tip}
## Check-in
Reproject the `places` geo-datafarme into `alaska`'s CRS and verify the CRSs match using `assert`.

<!--
```{python}
# Reproject to match Alaska CRS
places = places.to_crs(alaska.crs)
assert alaska.crs == places.crs
```
-->
:::


Let's check that map again:

```{python}
fig, ax = plt.subplots()

alaska.plot(ax=ax)
places.plot(ax=ax, color='red', markersize=2)

plt.show()
```

This is better: we can see there the Alaska poygons and some of the `places` points on top of it. 
Our next step is to select these points. 

<!--TODO: add if-else here with reprojecting -->

## Clipping

**Clipping** means using a polygon (or polygons) to only select geospatial data within them. 
Clipping a `geopandas.GeoDataFrame` is simple using the geopandas [`clip()` function](https://geopandas.org/en/stable/docs/reference/api/geopandas.clip.html). 
The general syntax is:
```python
updated_geodf = geopandas.clip(geodf, mask)
```
where:

- `updated_geodf` is the output of the method: the intersection of the geometries in `geodf` with `mask`,
- `geodf` is the `geopandas.GeoDataFrame` we want to clip, 
- `mask` is a `geopandas.GeoDataFrame` with the polygon(s) we want to use for clipping. This `mask` must be in the same CRS as `geodf`!

In our case:

```{python}
# Clip populated places to Alaska multipolygon
ak_places = gpd.clip(places, alaska)
print('Number of places in AK:', len(ak_places))
```

```{python}
# plot populated places in Alaska
fig, ax = plt.subplots()

alaska.plot(ax=ax)
ak_places.plot(ax=ax, color='red')

plt.show()
```

## Prepare roads 

### Exploration
Now we move on to our roads dataset. 

```{python}
# print the CRS
print(roads.crs)

# look at first five columns
roads.head(3)
```

```{python}
roads.plot()
```

### One-liner clipping

You may have already noticed that `roads` is not in the same CRS as `alaska`, so these geo-datasets shound't interact until they're in the same CRS. 
Before jumping right into reprojecting and clipping, we will subset the data to select only US roads:

```{python}
# select US roads only
usa_roads = roads[roads.sov_a3 == 'USA']
usa_roads.plot()
```

::: {.callout-caution}
## Reduce your tabular data before reducing via geometries
Geospatial operations are usually costly. 
The more detailed our geometries the longer in takes to do geospatial computations. 
It's a good practice to try to reduce your data as much as possible before applying any geospatial transformation. 
:::

<!--
YOU CAN JUMP FROM HERE TO CLIPPING WITH BOUNDING BOX
-->

We will now do a "one-liner" to clip `usa_roads` using the `alaska` polygon. Notice we are using the ouput of `usa_roads.to_crs(alaska.crs)` and thus not changing the `usa_roads` geo-dataframe or creating new variables:

```{python}
# clip usa_roads to alaska geometry
ak_roads = gpd.clip(usa_roads.to_crs(alaska.crs),alaska)

ak_roads.plot()
```

Notice how the lines break on the small islands? 
However in the `usa_roads` there are no broken lines. 
This should make us suspect we are leaving data out and clipping *exactly* to the polygons in `alaska` is not quite what we want. 

### Clipping with bounding box
We will clip the `usa_roads` geo-dataframe with the bounding box of `alaska` instead of its polygons. 
To create a bounding box, we first use the [`box()` function we imported from `shapely.geometry`](https://shapely.readthedocs.io/en/stable/manual.html#shapely.geometry.box). 
The syntax for `box()` is:
```python
box(minx, miny, maxx, maxy)
```
the output is a X representing a box constructed like this:

<!-- INSERT BOX DIAGRAM -->

If we want to create a shapely polygon from the bounds of a geo-dataframe `gdf`, a more straightforward syntax is:
```python 
box(*gdf.total_bounds)
```

<!-- ADD MORE DETAILS ABOUT THIS -->
In our case:

```{python}
bbox = box(*alaska.total_bounds)
print(type(bbox))
bbox
```

::: {.callout-tip}
## `*` as unpacking operator
In the last syntax we are using the asterisk `*` as an unpacking operator on the array `gdf.total_bounds`. 
Think about it as unpacking the elements of `gdf.total_bounds` and assigning them one-by-one to the paremeters `minx, miny, maxx, maxy` of `box()`.

This is a good article explaining more about unpacking with `*` in Python:
https://geekflare.com/python-unpacking-operators/
:::


```{python}
# create geo-dataframe from bounding box
ak_bbox = gpd.GeoDataFrame(geometry = [bbox], # assign geometry column
                           crs = alaska.crs) # assign CRS
print(type(ak_bbox))
ak_bbox
```

We can now clip the roads using Alaska's bounding box:
```{python}
ak_complete_roads = gpd.clip(usa_roads.to_crs(ak_bbox.crs), ak_bbox)
ak_complete_roads.plot()
```

Notice the difference between the two clipping methods:

```{python}
# two rows, one column
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10,10))

ak_roads.plot(ax=ax1)
ax1.set_title('Roads clipped with AK multipolygon')

ak_complete_roads.plot(ax=ax2)
ax2.set_title('Roads clipped with AK bounding box')

#plt.axis('equal')
plt.show()
```

<!-- 
Variable: Symbolic name that stores an object and has a reserved memory location.
-->

## Plot

Finally, we can put all our data together in the same map:

```{python}
# https://matplotlib.org/stable/api/markers_api.html
# Trouble: not in the same CRS
# this is cool! but now we are seeing all Arctic comms
fig, ax = plt.subplots(figsize=(12,8))
# --------------------------
ax.axis('off')

alaska.plot(ax=ax, color='none', edgecolor='0.7')
ak_complete_roads.plot(ax=ax, column='type', legend=True)
#ak_comms.plot(ax=ax, color='red')
ak_places.plot(ax=ax, color='red', marker='s')

# --------------------------

plt.show()
```